module P1Galerkin
  use Globals
  use LinearOperator
  use AbstractGeometry
  use SparseMatrix
  use DenseMatrix
  implicit none
  public :: p1_constructor, p1_destructor, assembly_stiff
  private
  !>--------------------------------------------------------------------------
  !> Structure variable coanting data of P1-Galerkin basis function
  !> given a surface triangualtion mesh $\Tau_h(\Omega)$ 
  !> with nnode nodes ( in R^3) and ncell triangles. 
  !> $P1(\Tau_h)$ is the finite-dimensional generated by linear combination
  !> of the function $(Psi_{i})_{i=1,nnode}$ such that
  !> $\Psi_i{x_j,y_j,z_j}=\delta_{i,j}$ for all node,
  !> and is denoted by $P1_{h}$.
  !> Example function in $P1_{h}$ is 
  !> $\PotH(x,y)=\sum_{i}^{nnode}u_i\Psi_{i}(x,y,z)$.
  !>--------------------------------------------------------------------------
  type, public :: p1gal
     !> Number of basis functions
     integer :: nbasis
     !> Number of cells 
     integer :: ncell 
     !> Tetrahedrons used 
     class(abs_simplex_mesh), pointer  :: grid
     !> Number of term for ssr (Symmetric  Sparse by Row)
     integer :: nterm_ssr = 0  
     !> Number of term for csr (Compressed Sparse by Row)
     integer :: nterm_csr = 0
     !> Dimension (grid%nnode+1)
     !> Pointer for diagonal term of ssr matrix 
     integer, allocatable :: ia_ssr(:)
     !> Dimension (nterm_ssr)
     !> Pointer for column index of ssr matrix
     integer, allocatable :: ja_ssr(:)
     !> Dimension (nnode_in_cell,nnode_incell,ncell)
     !> Pointer assembler_ssr for ssr matrix
     integer, allocatable :: assembler_ssr(:,:,:)
     !> Dimension (grid%nbasis+1)
     !> Pointer for diagonal term of csr matrix
     integer, allocatable :: ia_csr(:)
     !> Dimension (nterm_ssr)
     !> Pointer for column index of sparse symmetric matrixes
     integer, allocatable :: ja_csr(:)
     !> Dimension (nnode_in_cell,nnode_in_cell,ncell)
     !> Pointer assembler_csr for sparse symmetric matrixes
     !> Allows to pass from local to global node enumeration
     integer, allocatable :: assembler_csr(:,:,:)
     !> Dimension (logical_dimension+1,nnode_in_cell,ncell)
     !> Coefficients of the basis functions 'a + b*x + c*y + d*z' 
     !> over the triangles. 
     !> Each column corresponds to 
     !> node  1    2    3   4
     !> a  ( a1   a2   a3   a1   ) 
     !> b  ( b1_x b2_x b3_x b4_x )
     !> c  ( c1_y c2_y c3_y c3_y )
     !> d  ( d1_z d2_z d3_z d4_z )
     !> the node of mesh%topol
     !> Calculated in the constructor
     real(kind=double), allocatable :: coeff_basis(:,:,:)
     !> Dimension (logical_dimension,nnode_in_cell,ncell)
     !> Projection of gradient of the local basis functions
     !> On the triangle
     !> loc. index node  1          2          3  
     !> dx  (    dx(\Psi_1) dx(\Psi_2) dx(\Psi_3) )
     !> dy  (    dy(\Psi_1) dy(\Psi_2) dy(\Psi_3) )
     !> dz  (    dz(\Psi_1) dz(\Psi_2) dz(\Psi_3) )
     !> the node of mesh%topol
     !> Calculated in the constructor
     real(kind=double), allocatable :: grad_basis(:,:,:)

     !> Linear Operators from nnode space to logical_dimension*ncell 
     !> computiing the gradient 
     !> $\REAL^{logical_dimension*ncell} \ni \Grad u = ux = G \cdot u$  
     !>                                uy
     !>                                uz
     type(spmat) :: gradx
     type(spmat) :: grady
     type(spmat) :: gradz
     !> Linear Operator from nnode space to logical_dimension*ncell 
     !> computing the gradient (appropriate pointer to gradx,y,z) 
     !> $\REAL^{3*ncell} \ni \Grad u = ux = G \cdot u$ 
     !>                                uy
     !>                                uz
     type(block_linop) :: grad_operator
     !> Dimension (grid%nnode)
     !> Integral of the basis function
     !> Calculated in the constructor
     real(kind=double), allocatable :: basis_integral(:)
     !>
     !> Saint-Venant variables
     !>
     !> Number of nonzeros of Saint-Venant matrix equations
     !> nterm_saint_venant_csr = (grid%local_dimension)^2 * nterm 
     integer :: nterm_saint_venant_csr = 0
     !> Dimension (grid%local_dimension*grid%nbasis+1)
     !> Pointer for diagonal term of csr matrix
     integer, allocatable :: ia_saint_venant_csr(:)
     !> Dimension (nterm_saint_venant_csr)
     !> Pointer for column index of sparse symmetric matrixes
     integer, allocatable :: ja_saint_venant_csr(:)
     !> Dimension (dofsxcell,dofsxcell,ncell)
     !> Pointer assembler_csr for sparse symmetric matrixes
     !> Allows to pass from local to global node enumeration
     integer, allocatable :: assembler_saint_venant_csr(:,:,:)
     !> Constant vector with unit norm
     !> Kernel of stiff matrix 
     type(densemat) :: kernel_laplacian
     !> Constant vector with unit norm
     !> Kernel of stiff matrix 
     type(densemat) :: kernel_saint_venant
   contains
     !> static constructor
     !> (procedure public for type p1gal)
     procedure, public, pass :: init => init_p1gal
     !> static destructor
     !> (procedure public for type p1gal)
     procedure, public, pass :: kill => kill_p1gal
     !> Info procedure.
     !> (public procedure for type mesh)
     procedure, public, pass :: info => write_p1gal
     !> constructor of the coeff array of stiffness
     !> with conductivity tensor/coefficients
     !> (procedure public for type p1)
     procedure, public, pass :: build_stiff
     !> Constructor of the Stiffnes Matrix
     !> for the Saint Venant equations given
     !> a spatial varing conductivity tensor/coefficients
     !> The block matrices SXX SXY and SYY are created
     !> (procedure public for type p1)
     procedure, public, pass :: build_stiff_saint_venant_block_2D
     !> Constructor of the Stiffnes Matrix
     !> for the Saint Venant equations given
     !> a spatial varing conductivity tensor/coefficients
     !> (procedure public for type p1)
     procedure, public, pass :: build_stiff_saint_venant
     !> constructor of the coeff array of mass matrix
     !> with scalar coefficient
     !> (procedure public for type p1)
     procedure, public, pass :: build_mass
     !> construction of coeff array of lumped mass matrix
     !> from cell values (nodal mid-point rule)
     !> (procedure public for type p1gal)
     procedure, public, pass :: build_mass_lumped
     !> construction of coeff array of lumped mass matrix
     !> from nodal values 
     !> (procedure public for type p1gal)
     procedure, public, pass :: build_mass_lumped_trap
     !> constructor of the coeff array of advection matrix
     !> with vector-valued velocity coefficients
     !> (procedure public for type p1)
     procedure, public, pass :: build_adv
     !> constructor of the array of vector times
     !> gradient of basis functions
     !> (procedure public for type p1)
     procedure, public, pass :: build_VxGradphi
     !> constructor of the coeff array of mass matrix
     !> for the stabilization term with vector-valued
     !> velocity coefficients
     !> (procedure public for type p1)
     procedure, public, pass :: build_mass_stab
     !> constructor of the coeff array of stiffness matrix
     !> for the stabilization term with vector-valued
     !> velocity coefficients
     !> (procedure public for type p1)
     procedure, public, pass :: build_stiff_stab
     !> Compute the rhs for stabilization terms
     !> (procedure public for type p1)
     procedure, public, pass :: build_stab_forcing
     !> Compute the integral of piecewise constant
     !> functions defined on the grid or super grid
     !> (procedure public for type p1)
     procedure, public, pass :: int_test
     !> Compute the rhs of elliptic system 
     !> for given forcing and Neumann bc
     !> (procedure public for type p1)
     procedure, public, pass :: build_rhs_forcing
     !> Evaluation of the gradient $\nabla u_h$ retricted
     !> to a given cell
     !> (procedure public for building real array grad)
     procedure, public, pass :: eval_gradcell
     !> evaluation of the gradient $\nabla u_h$
     !> (procedure public for building real array grad)
     procedure, public, pass :: eval_grad
     !> evaluation of the euclidean norm of the gradient
     !> over a cell $|\nabla u_h$|$ 
     !> (procedure public for building real array nrm_grad)
     procedure, public, pass :: eval_nrm_grad
     !> Evaluation of the strain energy density for the 
	  !> linear elasticity problem over a cell:
     !> $\mu|\epsilon (u)|^2 + \frac{\lambda}{2}|\div(u)|^2$
     !> (procedure public for building real array nrm_grad)
     procedure, public, pass :: eval_strain_energy
     !> Evaluation of the strain energy density for the 
     !> linear elasticity problem over a cell:
     !> $\mu|\epsilon (u)|^2 + \frac{\lambda}{2}|\div(u)|^2$
     !> (procedure public for building real array nrm_grad)
     procedure, public, pass :: eval_strain
     !> Procedure to get the gradient of a basis functions
     !> for a given cell
     !> (procedure public for building real array grad)
     procedure, public, pass :: get_gradbase
     !> Evaluation of the flux $- K \nabla u_h$ retricted
     !> to a given cell
     !> (procedure public for building real array flux)
     procedure, public, pass :: eval_fluxcell
     !> evaluation of the flux $- K\nabla u_h$
     !> (procedure public for building real array flux)
     procedure, public, pass :: eval_flux
     !> Procedure for the construction of the nodes permutation 
     !> that minimize bandwidth for P1 Galerkin
     !> It finds the reverse Cuthill-Mckee ordering 
     !> for adjacency matrix
     !>(procedure public for type p1gal)
     procedure, public, pass :: genrcm
     !> Procedure for imposing Dirichlet boundary condition to the 
     !> system matrix and rhs
     !> (procedure public for type p1gal)
     procedure, public, pass :: dirichlet_bc
     !>--------------------------------------------------------------------
     !> Private Procedures (used in init)
     !>--------------------------------------------------------------------
     !> construction of the coefficients of the P1-basis function
     !> (procedure private for type p1gal member 
     !> coeff_basis initializated in the procedure. Used in init)
     procedure, private, pass :: build_coeff
     !> Constructor of basis_integral array. 
     !> (procedure private for type p1gal member basis_integral. Used in init)
     procedure, private, pass :: build_basis_integral
     !> Builds the pointer ia_ssr, ja_ssr for symmetric sparse matrix
     !> (procedure private for type p1gal. Used in init)
     procedure, private, pass :: build_iaja_ssr
     !> construction of the hyper-pointer assembly for sym. sparse matix
     !> (procedure private for integer array: assembler_ssr
     !> initialized in the procedure. Used in init)
     procedure, private, nopass :: build_assembler_ssr
     !> Builds the pointer ia_csr, ja_csr 
     !> (procedure private for type p1gal. Used in init)
     procedure, private, pass :: build_iaja_csr
     !> Procedure for the construction 
     !> of the hyper-pointer assembly for sparse matrix
     !> in csr format
     !> (procedure private for integer array: assembler
     !> initialized in the procedure. Used in init)
     procedure, private, nopass :: build_assembler_csr
     !> Builds the pointer ia_saint_venant_csr, ja_saint_venant_csr
     !> and assembler_saint_venant_csr
     !> (procedure private for type p1gal. Used in init)
     procedure, private, pass :: build_ia_ja_assembler_saintvenant_csr => build_csr_multi_dofs
     !> Procedure for build
     !> sparse matrices with the gradient of the basis funciton
     procedure, public, pass :: gradbase2spmat
	  procedure, public, pass :: neumann_elasticity_rhs
	  procedure, public, pass :: neumann_elasticity_pot 
  end type p1gal
contains
  !>-------------------------------------------------------------
  !> Static constructor.
  !> (procedure public for type p1 gal
  !> Instantiate and initilize )
  !>
  !> usage:
  !>     call 'var'%init(this, lun_err, grid)
  !>
  !> where:
  !> \param[in] lun_err -> integer. Logic unit for error message
  !> \param[in] grid    -> type(mesh). Data of the mesh
  !<-------------------------------------------------------------
  subroutine init_p1gal(this, lun_err, grid)
    use Globals
    use AbstractGeometry
    implicit none
    !vars
    class(p1gal), target,       intent(out) :: this
    integer,                    intent(in ) :: lun_err
    class(abs_simplex_mesh), target, intent(in ) :: grid
    ! local variables
    integer :: nnode,n1,ncell,nterm,nnodeincell
    integer :: res,i,inode,dim_kernel
    logical :: rc
    ! jacobian 
    type(array_linop) :: block_list(3)
    integer :: block_structure(3,3)
    ! function
    real(kind=double) :: ddot,dnrm2,coord(3)
    
  
    nnode=grid%nnode
    ncell=grid%ncell
    nnodeincell=grid%nnodeincell
  
    this%nbasis = grid%nnode
    this%ncell = grid%ncell

    this%grid => grid
    
    !local copy of the length of integer array
    !n1>max number of triangles connected to the same node
     
    !
    ! build ia_ssr, ja_ssr and nterm_ssr for ssr format
    ! build ia_csr, ja_csr and nterm_csr for csr format
    !
    n1=40     
    call this%build_iaja_ssr(lun_err,n1,grid)
    call this%build_iaja_csr(lun_err,n1,grid)

    !
    ! initialization and construction of assembler for ssr storage
    !
    allocate(this%assembler_ssr(nnodeincell,nnodeincell,ncell),stat=res)
    if(res .ne. 0) rc = IOerr(lun_err, err_alloc, 'init_p1gal', &
         ' type p1gal member assembler_ssr',res)
    call build_assembler_ssr(nnode, ncell, nnodeincell, this%nterm_ssr, &
         this%ia_ssr, this%ja_ssr,  this%assembler_ssr,this%grid)

    !
    ! initialization and construction of assembler for csr storage
    !
    allocate(this%assembler_csr(nnodeincell,nnodeincell,ncell),stat=res)
    if(res .ne. 0) rc = IOerr(lun_err, err_alloc, 'init_p1gal', &
         ' type p1gal member assembler_csr',res)
    call build_assembler_csr(nnode, ncell, nnodeincell, this%nterm_csr, &
         this%ia_csr, this%ja_csr,  this%assembler_csr,this%grid)

    !
    ! initialization of variable for building
    ! stiffness matrix of saint-venant eqs.
    !
    call this%build_ia_ja_assembler_saintvenant_csr()

    !
    ! initialization and construction of area_basis
    !
    call this%build_basis_integral(lun_err)
    
    !
    ! initialization and construction of
    ! coefficient a,b,c of local basis function a+bx+cy
    ! for each triangle
    call this%build_coeff(lun_err)    

    call this%gradbase2spmat(lun_err,&
       this%gradx, this%grady, this%gradz)
   
    block_structure(:,1) = (/1,1,1/) ! A
    block_list(1)%linop => this%gradx

    block_structure(:,2) = (/2,1,2/) ! B^T      matrix in 1,2 
    block_list(2)%linop =>  this%grady

    block_structure(:,3) = (/3,1,3/) ! -dt D1 B matrix in 2,1
    block_list(3)%linop => this%gradz

    call this%grad_operator%init(&
         lun_err,&
         grid%logical_dimension, block_list(1:grid%logical_dimension),&
         1 , grid%logical_dimension, grid%logical_dimension,&
         block_structure(:,1:grid%logical_dimension),.false.)

    !
    ! create the kernl of laplacian with pure neumann BC 
    !
    call this%kernel_laplacian%init(lun_err,&
         nnode,1,is_symmetric=.False.,triangular='N')
    this%kernel_laplacian%coeff=one/sqrt(one*nnode)

    !
    ! create the kernel of saint-venatn equaitons with pure neumann BC 
    !
  

    if ( grid%ambient_dimension .eq. 2) then
       ! 3 vecotr in 2d, 6 vector in 3d 
       dim_kernel=3*grid%ambient_dimension
       call this%kernel_saint_venant%init(lun_err,&
            grid%ambient_dimension*nnode,dim_kernel,is_symmetric=.False.,triangular='N')
       
       this%kernel_saint_venant%coeff=zero
       do inode = 1,nnode
          this%kernel_saint_venant%coeff(2*inode-1,1)=one
          this%kernel_saint_venant%coeff(2*inode  ,2)=one
          call this%grid%get_coord_of_node(inode, coord)
          this%kernel_saint_venant%coeff(2*inode-1,3) = coord(2)
          this%kernel_saint_venant%coeff(2*inode  ,3)=-coord(1)
       end do
       this%kernel_saint_venant%coeff(:,1)=this%kernel_saint_venant%coeff(:,1)/&
            sqrt(one*nnode)
       this%kernel_saint_venant%coeff(:,2)=this%kernel_saint_venant%coeff(:,2)/&
            sqrt(one*nnode)
       
       !
       ! ortogonalization of the third kernel vector
       !
       this%kernel_saint_venant%coeff(:,3)=&
            this%kernel_saint_venant%coeff(:,3)&
            - ddot(nnode,&
            this%kernel_saint_venant%coeff(:,3),1,&
            this%kernel_saint_venant%coeff(:,1),1)*this%kernel_saint_venant%coeff(:,1) &
            - ddot(nnode,&
            this%kernel_saint_venant%coeff(:,3),1,&
            this%kernel_saint_venant%coeff(:,2),1)*this%kernel_saint_venant%coeff(:,2)

       this%kernel_saint_venant%coeff(:,3) = this%kernel_saint_venant%coeff(:,3)/ &
            dnrm2(nnode,this%kernel_saint_venant%coeff(:,3),1)
    end if


  end subroutine init_p1gal

  subroutine p1_constructor(this, lun_err, grid)
    use Globals
    use AbstractGeometry
    implicit none
    !vars
    type(p1gal),      intent(inout) :: this
    integer,            intent(in ) :: lun_err
    type(abs_simplex_mesh), target, intent(in ) :: grid

    call this%init(lun_err,grid)

  end subroutine p1_constructor

  !>-------------------------------------------------------------
  !> Static destructor.
  !> (procedure public for type p1gal)
  !> deallocate all arrays for a var of type p1gal
  !>
  !> usage:
  !>     call 'var'%kill(lun)
  !>
  !> where:
  !> \param[in] lun -> integer. I/O unit for error message output
  !>
  !<-----------------------------------------------------------
  subroutine kill_p1gal(this, lun)
    implicit none
    ! vars
    class(p1gal), intent(inout) :: this
    integer, intent(in) :: lun
    ! local vars
    integer :: res,i
    logical :: rc

    if (allocated(this%ia_ssr)) then
       deallocate(this%ia_ssr,stat=res)
       if (res.ne.0) rc=IOerr(lun, err_dealloc, 'kill_p1gal', &
            'dealloc fail for p1gal member ia_ssr')
    end if

    if (allocated(this%ja_ssr)) then
       deallocate(this%ja_ssr,stat=res)
       if (res.ne.0) rc=IOerr(lun, err_dealloc, 'kill_p1gal', &
            'dealloc fail for p1gal member ja_ssr')
    end if

    if (allocated(this%ia_csr)) then
       deallocate(this%ia_csr,stat=res)
       if (res.ne.0) rc=IOerr(lun, err_dealloc, 'kill_p1gal', &
            'dealloc fail for p1gal member ia_csr')
    end if

    if (allocated(this%ja_csr)) then
       deallocate(this%ja_csr,stat=res)
       if (res.ne.0) rc=IOerr(lun, err_dealloc, 'kill_p1gal', &
            'dealloc fail for p1gal member ja_csr')
    end if


    if (allocated(this%assembler_ssr)) then
       deallocate(this%assembler_ssr,stat=res)
       if (res.ne.0) rc=IOerr(lun, err_dealloc, 'kill_p1gal', &
            'dealloc fail for p1gal member assembler_ssr')
    end if

    if ( allocated(this%coeff_basis) ) then
       deallocate(this%coeff_basis,stat=res)
       if (res.ne.0) rc=IOerr(lun, err_dealloc, 'kill_p1gal', &
            'dealloc fail for p1gal member coeff_basis')
    end if

    if (allocated(this%basis_integral)) then
       deallocate(this%basis_integral,stat=res)
       if (res.ne.0) rc=IOerr(lun, err_dealloc, 'kill_p1gal', &
            'dealloc fail for p1gal member basis_integral ')
    end if

  end subroutine kill_p1gal


  subroutine p1_destructor(this, lun)
    implicit none
    ! vars
    type(p1gal), intent(inout) :: this
    integer, intent(in) :: lun

    call this%kill(lun)
  end subroutine p1_destructor
    
  !>-------------------------------------------------------------
  !> Info procedure.
  !> (public procedure for type p1gal)
  !> Prints content of a variable of type mesh
  !> 
  !> usage:
  !>     call 'var'%info(lun)
  !>
  !> where:
  !> \param[in] lun -> integer. I/O unit for error message output
  !>
  !<-------------------------------------------------------------
  subroutine write_p1gal(this, lun)
    use Globals
    implicit none
    class(p1gal), intent(in) :: this
    integer, intent(in) :: lun
    !
    integer :: nnode, ncell, nnodeincell
    integer :: inode, icell,j
    write(lun,*) ' Info: p1gal structure infromation:'
    nnode=this%grid%nnode
    ncell=this%grid%ncell
    nnodeincell=this%grid%nnodeincell

1000 format(4i12)
    write(lun,*) ' CSR Assembler'
    write(lun,*) ' Number of cell'
    write(lun,*) ' assembler(i,j,icell) for i,j=1,nnodeincell'

    do icell=1,ncell
       write(lun,*) ' Cell',icell
       do j=1,nnodeincell
          write(lun,*) this%assembler_csr(j,:,icell)
       end do
    end do
    write(lun,*) ' '

    write(lun,*) ' Coefficients of the P1 basis function a+bx+cy+dz'
    write(lun,*) ' Number of tetrahedron'
    write(lun,*) ' a_v1 a_v2 a_v3 a_v4 '
    write(lun,*) ' b_v1 b_v2 b_v3 b_v4 '
    write(lun,*) ' c_v1 c_v2 c_v3 c_v4 '
    write(lun,*) ' d_v1 d_v2 d_v3 d_v4 '
1010 format(4(1pe12.4))
    do icell=1,ncell
       write(lun,*) ' Cell ',icell
       do j=1,this%grid%logical_dimension+1
          write(lun,1010) this%coeff_basis(j,:,icell)
       end do
    end do
    write(lun,*) ' '

    write(lun,*) 'Volume related to each node'
    do inode = 1,nnode
       write(lun,*) ' Node',inode,'integral',this%basis_integral(inode)
    end do
    write(lun,*) ' '
  end subroutine write_p1gal


  !>-------------------------------------------------------------
  !> Part of the static constructor.
  !> (procedure private for type p1gal member coeff_basis
  !> used in init. Follows 
  !> http://www.math.unipd.it/~putti/teaching/metodi-mat/
  !>               esercitazione/esercitazione-fem.pdf
  !> Allocate and build matrix coeff_basis)
  !>
  !> usage:
  !>     call var%build_coeff(lun_err, grid)
  !>
  !> where:
  !> \param[in ] lun_err -> integer. Logic unit for error message
  !<-------------------------------------------------------------
  subroutine build_coeff(this, lun_err)
    use Globals
    implicit none
    class(p1gal), intent (inout) :: this
    integer, intent(in) :: lun_err
    ! local variables
    integer res
    integer ncell,nnodeincell, ambient_dimension,nodes(4)
    integer icell, inodeloc,i,j,k,inode,inode2
    integer :: ipiv(this%grid%logical_dimension+1), info
    real(kind=double) :: xl(this%grid%nnodeincell),&
         yl(this%grid%nnodeincell),&
         zl(this%grid%nnodeincell)
    real(kind=double) :: t3loc(3),gradf(3),Hf(3,3),coord(3)
    real(kind=double), allocatable:: local_mat(:,:), local_b(:)
    logical rc

    ncell             = this%grid%ncell
    nnodeincell       = this%grid%nnodeincell
    ambient_dimension = this%grid%ambient_dimension
    
    allocate(&
         this%coeff_basis(ambient_dimension+1,nnodeincell,ncell),&
         this%grad_basis(ambient_dimension,nnodeincell,ncell),&
         stat=res)
    if(res .ne. 0) rc = IOerr(lun_err, err_alloc , 'build coeff',&
         'type p1gal member coeff_basis',res)
    

    select case ( this%grid%mesh_type ) 
    case ('2d')
       allocate(&
            local_mat(3,3),&
            local_b(3),&
            stat=res)
       if(res .ne. 0) rc = IOerr(lun_err, err_alloc , 'build coeff',&
            'work arrays local_mat, local_b ',res)
       do icell=1,ncell
          !
          ! set the matrix of the local system
          !     ( 1 x_v1 y_v1 )
          ! A = ( 1 x_v2 y_v2 )
          !     ( 1 x_v3 y_v3 )
          !
          local_mat = zero
          local_mat(1:3,1) = one          
          call this%grid%get_nodes_in_cell(icell,nnodeincell,&
               nodes(1:nnodeincell))
          do inodeloc=1,nnodeincell
             call this%grid%get_coord_of_node(nodes(inodeloc), coord)

             local_mat(inodeloc,2) = coord(1)
             local_mat(inodeloc,3) = coord(2)
          end do
          
          !
          ! factor local 3x3 matrix system
          !
          call DGETRF(3, 3, local_mat, 3, ipiv, info )
          
          do inodeloc=1,nnodeincell
             !
             ! set the rhs of the local system
             !    b=\delta_{inodeloc}
             !
             local_b = zero
             local_b(inodeloc) = one
             call DGETRS('N', 3, 1, local_mat, 3, ipiv, local_b,&
                  3, info)
             
             this%coeff_basis(1:3,inodeloc,icell) = local_b(1:3)
             !
             ! copy term b c (d=0)
             !
             this%grad_basis(1:2,inodeloc,icell)=&
                  this%coeff_basis(2:3,inodeloc,icell)
          end do
       end do
       
    case ('3d')
       allocate(&
            local_mat(4,4),&
            local_b(4),&
            stat=res)
       if(res .ne. 0) rc = IOerr(lun_err, err_alloc , 'build coeff',&
            'work arrays local_mat, local_b ',res)
       do icell=1,ncell
          !
          ! set the matrix of the local system
          !     ( 1 x1 y1 z1 )
          ! A = ( 1 x2 y2 z2 )
          !     ( 1 x3 y3 z3 )
          !     ( 1 x4 y4 z4 )
          !
          local_mat = zero
          local_mat(:,1) = one

          call this%grid%get_nodes_in_cell(icell,nnodeincell,&
               nodes(1:nnodeincell))
          do inodeloc=1,nnodeincell
             call this%grid%get_coord_of_node(nodes(inodeloc), coord)
             local_mat(inodeloc,2) = coord(1)
             local_mat(inodeloc,3) = coord(2)
             local_mat(inodeloc,4) = coord(3)
          end do
          
          !
          ! factor local matrix system
          !
          call DGETRF(4, 4, local_mat, 4, ipiv, info )
          
          do inodeloc=1,nnodeincell
             !
             ! set the rhs of the local system
             !    b=\delta_{inodeloc}
             !
             local_b = zero
             local_b(inodeloc) = one
             call DGETRS('N', 4, 1, local_mat, 4, ipiv, local_b,&
                  4, info)
             
             this%coeff_basis(1:4,inodeloc,icell) = local_b(1:4)

             !
             ! copy term b c d
             !
             this%grad_basis(1:3,inodeloc,icell)=&
                  this%coeff_basis(2:4,inodeloc,icell)
          end do     
       end do       
    case ('surface') 
       allocate(&
            local_mat(4,4),&
            local_b(4),&
            stat=res)
       if(res .ne. 0) rc = IOerr(lun_err, err_alloc , 'build coeff',&
            'work arrays local_mat, local_b ',res)
       
       do icell=1,ncell
          call this%grid%get_nodes_in_cell(icell,nnodeincell,&
               nodes(1:nnodeincell))
          do inodeloc=1,nnodeincell
             call this%grid%get_coord_of_node(nodes(inodeloc), coord)
             ! nodal coordinates
             xl(inodeloc)=coord(1)
             yl(inodeloc)=coord(2)
             zl(inodeloc)=coord(3)
          end do
          
          !
          ! select normal 
          !
          t3loc = this%grid%normal_cell(:,icell)
             
          do inodeloc=1,nnodeincell          
             ! set the rhs of the local system
             local_b = zero
             local_b(inodeloc) = one
             
             ! set the matrix of the local system
             local_mat = zero
             local_mat(:,1) = one
             local_mat(1:3,2) = xl
             local_mat(1:3,3) = yl 
             local_mat(1:3,4) = zl
             local_mat(4,2) = xl(inodeloc)+t3loc(1)
             local_mat(4,3) = yl(inodeloc)+t3loc(2)
             local_mat(4,4) = zl(inodeloc)+t3loc(3)

             !
             ! solve the local system copy result
             ! into matrix coeffic
             !
             call DGETRF(4, 4, local_mat, 4, ipiv, info )
             call DGETRS('N', 4, 1, local_mat, 4, ipiv, local_b,&
                  4, info)

             
             this%coeff_basis(:,inodeloc,icell) = local_b(:)
             
             !
             ! project gradients
             !
             call orthogonal_projection(&
                  3,&
                  this%coeff_basis(2:4,inodeloc,icell),&
                  t3loc,&
                  this%grad_basis(1:3,inodeloc,icell))
          end do   
       end do
    end select

    !
    ! free memory
    ! 

    deallocate(&
         local_mat,&
         local_b,&
         stat=res)
    if(res .ne. 0) rc = IOerr(lun_err, err_dealloc , 'build coeff',&
         'work arrays local_mat, local_b ',res)

  end subroutine build_coeff

  
  !>-------------------------------------------------------------
  !> Procedure for build of the stiffness matrix
  !> $S(i,j)=\int_{\Domain} K \Grad \Psi_i \Grad \Psi_j$
  !> (procedure private for type p1gal)
  !> The format of the produced stiffness matrix can be in ssr or csr
  !>
  !> usage:
  !>     call 'var'%build_stiff(lun_err,imem,cond,stiff)
  !>
  !> where:
  !> \param[in   ] lun_err             -> integer. I/O unit err. msg.
  !> \param[in   ] imem                -> integer. Storage system used
  !> \param[in   ] cond                -> real(double).
  !>                                      assumed dimension:
  !>                                      - ncell   = scalar value
  !>                                      - 3*ncell = 2D-anisotropic
  !>                                        (c11,c21,c22)x(1,..,ncell)
  !>                                      - 6*ncell = 3D-anisotropic
  !>                                        (c11,c21,c22,c31,c32,c33)
  !>                                                     x(1,..,ncell)
  !> \param[inout] stiff               -> spmat.   Stiff matrix
  !<-------------------------------------------------------------
  subroutine build_stiff(this, lun_err, storage_system, cond, stiff, vscal)
    use Globals
    use SparseMatrix
    implicit none
    class(p1gal),      intent(in   ) :: this
    integer,           intent(in   ) :: lun_err
    character(len=3),  intent(in   ) :: storage_system
    real(kind=double), intent(in   ) :: cond(:)
    type(spmat),       intent(inout) :: stiff
    real(kind=double), optional, intent(in) :: vscal(:)
    ! local
    logical     :: rc 
    integer     :: nbasis,nterm,ncell
    
    nbasis= this%nbasis
    ncell = this%grid%ncell

    
    if ( storage_system .eq. 'ssr' ) nterm=this%nterm_ssr
    if ( storage_system .eq. 'csr' ) nterm=this%nterm_csr

    if ( .not. stiff%is_initialized ) then
       call stiff%init(lun_err, &
            nbasis,nbasis,nterm,&
            storage_system,&
            is_symmetric=.true.) 
    else
       ! check if passed matrix has been initilized properly
       if ( .not. stiff%check(&
            nbasis,nbasis,nterm,&
            storage_system=storage_system) ) then
          rc = IOerr(lun_err, err_val, 'build_stiff', &
               ' Matrix Stiff  has not the proper dimension')
       end if
    end if

    if (size(cond)/ncell.eq.1) then
       if ( storage_system .eq. 'ssr' ) &
            call assembly_stiff_ssr(this,cond,stiff)
       if ( storage_system .eq. 'csr' ) &
            call assembly_stiff_csr(this,cond,stiff)       
    else if (size(cond)/ncell.eq.3 .or. &
       size(cond)/ncell.eq.6) then
       if ( storage_system .eq. 'ssr' ) &
            call assembly_stiff_anis_ssr(this,cond,stiff,vscal)
       if ( storage_system .eq. 'csr' ) then
          call assembly_stiff_anis_csr(this,cond,stiff,vscal)
       end if
       
    else
       rc = IOerr(lun_err,err_inp,'assembly_stiff',&
            ' cond: wrong dimensions') 
    end if

  contains
    ! Assembly procedure for stiff matrix in ssr format
    ! when cond is a scalar
    subroutine assembly_stiff_ssr(this,cond,stiff)
      use Globals
      use SparseMatrix
      implicit none
      class(p1gal),      intent(in   ) :: this
      real(kind=double), intent(in   ) :: cond(this%grid%ncell)
      type(spmat),       intent(inout) :: stiff
      ! local variables
      integer :: icell,i,j,ind
      integer :: nnodeincell,ndim,ncell,ldim
      integer :: flag_anis
      real(kind=double) :: gradbase(this%grid%logical_dimension),&
           gradtest(this%grid%logical_dimension)
      real(kind=double) :: ddot
      logical :: test

      nnodeincell = this%grid%nnodeincell
      ndim        = this%grid%ambient_dimension
      ldim        = this%grid%logical_dimension
      ncell       = this%grid%ncell
      
      !
      ! assign ia and ja
      !
      stiff%ia = this%ia_ssr
      stiff%ja = this%ja_ssr
      call stiff%build_ind_diag(6)
      
      !
      ! assembly coeff
      !
      stiff%coeff = zero
      !
      do icell=1,ncell
         do j = 1,nnodeincell
            !
            ! get coefficient of the gradient of the local basis functions
            !
            call this%get_gradbase(j,icell,gradbase)
            do i = j,nnodeincell
               !
               ! get coefficient of the gradient of the local test functions
               !
               call this%get_gradbase(i,icell,gradtest)
               ind = this%assembler_ssr(i,j,icell)
               stiff%coeff(ind) = stiff%coeff(ind) + &
                    cond(icell) * this%grid%scalar_product(gradbase,gradtest) * &
                    this%grid%size_cell(icell)
            end do
         end do
      end do
      
    end subroutine assembly_stiff_ssr

    ! Assembly procedure for stiff matrix in csr format
    ! when cond is a scalar
    subroutine assembly_stiff_csr(this,cond,stiff)
      use Globals
      use SparseMatrix
      implicit none
      class(p1gal),      intent(in   ) :: this
      real(kind=double), intent(in   ) :: cond(this%grid%ncell)
      type(spmat),       intent(inout) :: stiff
      ! local variables
      integer :: icell,i,j,ind
     integer :: nnodeincell,ndim,ncell,ldim
     real(kind=double) :: gradbase(this%grid%logical_dimension),&
          gradtest(this%grid%logical_dimension)
      real(kind=double) :: ddot

      nnodeincell = this%grid%nnodeincell
      ndim        = this%grid%ambient_dimension
      ldim        = this%grid%logical_dimension      
      ncell       = this%grid%ncell
      
      !
      ! assign ia and ja
      !
      stiff%ia = this%ia_csr
      stiff%ja = this%ja_csr
      call stiff%build_ind_diag(6)
      
      !
      ! assembly coeff
      !
      stiff%coeff = zero
      !
      do icell=1,ncell
         do j = 1,nnodeincell
            !
            ! get coefficient of the gradient of the local basis functions
            !
            call this%get_gradbase(j,icell,gradbase)
            do i = 1,nnodeincell
               !
               ! get coefficient of the gradient of the local test functions
               !
               call this%get_gradbase(i,icell,gradtest)
               ind = this%assembler_csr(i,j,icell)
               stiff%coeff(ind) = stiff%coeff(ind) + &
                    cond(icell) * this%grid%scalar_product(gradbase,gradtest)*&
                    this%grid%size_cell(icell)
            end do
         end do
      end do
      
    end subroutine assembly_stiff_csr

    ! Assembly procedure for stiff matrix in ssr format
    ! when cond is a ldim x ldim matrix (anisotropy)
    subroutine assembly_stiff_anis_ssr(this,cond,stiff,vscal)
      use Globals
      use SparseMatrix
      implicit none
      class(p1gal),      intent(in   ) :: this
      real(kind=double), intent(in   ) :: &
           cond(this%grid%logical_dimension*&
           (this%grid%logical_dimension+1)/2&
           *this%grid%ncell)
      type(spmat),       intent(inout) :: stiff
      real(kind=double), optional, intent(in) :: vscal(this%grid%ncell)
      ! local variables
      integer :: icell,i,j,ind
      integer :: nnodeincell,ndim,ncell,ldim
      real(kind=double) :: gradbase(this%grid%logical_dimension),&
           gradtest(this%grid%logical_dimension)
      real(kind=double) :: &
           cond_loc(this%grid%logical_dimension,this%grid%logical_dimension)
      real(kind=double) :: ddot
      real(kind=double) :: vscal_loc(this%grid%ncell)

      nnodeincell = this%grid%nnodeincell
      ndim        = this%grid%ambient_dimension
      ldim        = this%grid%logical_dimension      
      ncell       = this%grid%ncell
          
      !
      ! assign ia and ja
      !
      stiff%ia = this%ia_ssr
      stiff%ja = this%ja_ssr
      call stiff%build_ind_diag(6)

      vscal_loc = one
      if(present(vscal)) vscal_loc = vscal
      
      !
      ! assembly coeff
      !
      stiff%coeff = zero
      !
      do icell=1,ncell
         cond_loc = get_cond_loc(ncell,ldim,icell,cond)
         do j = 1,nnodeincell
            !
            ! get coefficient of the gradient of the local base functions
            !
            call this%get_gradbase(j,icell,gradbase)
            gradbase = matmul(cond_loc,gradbase)
            do i = j,nnodeincell
               !
               ! get coefficient of the gradient of the local test functions
               !
               call this%get_gradbase(i,icell,gradtest)
               ind = this%assembler_ssr(i,j,icell)
               stiff%coeff(ind) = stiff%coeff(ind) + &
                    this%grid%scalar_product(gradbase,gradtest) * &
                    vscal_loc(icell) * &
                    this%grid%size_cell(icell)
            end do
         end do
      end do
            
    end subroutine assembly_stiff_anis_ssr

    ! Assembly procedure for stiff matrix in csr format
    ! when cond is a ldim x ldim matrix (anisotropy)
    subroutine assembly_stiff_anis_csr(this,cond,stiff,vscal)
      use Globals
      use SparseMatrix
      implicit none
      class(p1gal),      intent(in   ) :: this
      real(kind=double), intent(in   ) :: &
           cond(this%grid%logical_dimension*&
           (this%grid%logical_dimension+1)/2&
           *this%grid%ncell)
      type(spmat),       intent(inout) :: stiff
      real(kind=double), optional, intent(in) :: vscal(this%grid%ncell)
      ! local variables
      integer :: icell,i,j,ind
      integer :: nnodeincell,ndim,ncell,ldim
      real(kind=double) :: gradbase(this%grid%logical_dimension),&
           gradtest(this%grid%logical_dimension)
      real(kind=double) :: &
           cond_loc(this%grid%logical_dimension,this%grid%logical_dimension)
      real(kind=double) :: ddot
      real(kind=double) :: vscal_loc(this%grid%ncell)


      nnodeincell = this%grid%nnodeincell
      ndim        = this%grid%ambient_dimension
      ldim        = this%grid%logical_dimension
      ncell       = this%grid%ncell

      !
      ! assign ia and ja
      !
      stiff%ia = this%ia_csr
      stiff%ja = this%ja_csr
      call stiff%build_ind_diag(6)

      vscal_loc = one
      if(present(vscal)) vscal_loc = vscal
      
      !
      ! assembly coeff
      !
      stiff%coeff = zero
      !
      do icell=1,ncell
         cond_loc = get_cond_loc(ncell,ldim,icell,cond)
         do j = 1,nnodeincell
            !
            ! get coefficient of the gradient of the local base functions
            !
            call this%get_gradbase(j,icell,gradbase)
            gradbase=matmul(cond_loc,gradbase)
            do i = 1,nnodeincell
               !
               ! get coefficient of the gradeint of the local test fucntions
               !
               call this%get_gradbase(i,icell,gradtest)
               ind = this%assembler_csr(i,j,icell)
               stiff%coeff(ind) = stiff%coeff(ind) + &
                    this%grid%scalar_product(gradbase,gradtest) *&
                    vscal_loc(icell) * &
                    this%grid%size_cell(icell)
            end do
         end do
      end do
      
    end subroutine assembly_stiff_anis_csr
    
  end subroutine build_stiff

  !>-------------------------------------------------------------
  !> Procedure for build of the compenents
  !> Sxx Sxy Syy of the stiffness matrix
  !> (Sxx     Sxy)
  !> (Syx=Syx Syy)
  !> of Saint Venant Equaitions given by
  !> $S = \int_{\Domain} K(x,y) \epsilon(u(x,y)) : C \epsion(u(x,y))
  !> (procedure private for type p1gal)
  !> The format of the produced stiffness matrix can be in ssr or csr
  !>
  !> usage:
  !>     call 'var'%build_stiff_saint_venant_block_2D(lun_err,&
  !>			mu,lambda,cond,stiffxx,stiffxy,stiffyy)
  !>
  !> where:
  !> \param[in   ] lun_err             -> integer. I/O unit err. msg.
  !> \param[in   ] mu                  -> real(double). First Lamè constant
  !> \param[in   ] lambda              -> real(double). Second Lamè constant
  !> \param[in   ] cond                -> real(double).
  !>                                      assumed dimension:
  !>                                      - ncell   = scalar value
  !> \param[inout] stiffxx             -> spmat. XX component  Stiff matrix
  !> \param[inout] stiffxy             -> spmat. XY component  Stiff matrix
  !> \param[inout] stiffyy             -> spmat. YY component  Stiff matrix
  !<-------------------------------------------------------------
  subroutine build_stiff_saint_venant_block_2D(this,&
       lun_err,mu,lambda,cond,stiffxx,stiffxy,stiffyy)
    use Globals
    use SparseMatrix
    implicit none
    class(p1gal),      intent(in   ) :: this
    integer,           intent(in   ) :: lun_err
    real(kind=double), intent(in   ) :: mu
    real(kind=double), intent(in   ) :: lambda
    real(kind=double), intent(in   ) :: cond(:)
    type(spmat),       intent(inout) :: stiffxx
    type(spmat),       intent(inout) :: stiffxy
    type(spmat),       intent(inout) :: stiffyy
    ! local
    logical     :: rc 
    integer     :: nbasis,nterm,ncell
    integer :: icell,i,j,ind
    integer :: nnodeincell,ndim,ldim
    real(kind=double) :: gradbase(this%grid%logical_dimension),&
         gradtest(this%grid%logical_dimension)
    real(kind=double) :: ddot
    
    nbasis = this%nbasis
    ncell = this%grid%ncell

    !if ( storage_system .eq. 'csr' ) nterm=this%nterm_csr
    
    nterm = this%nterm_csr
    
    if ( stiffxx%is_initialized ) call stiffxx%kill(lun_err) 
    call stiffxx%init(lun_err, &
         nbasis,nbasis,nterm,&
         'csr',&
         is_symmetric=.true.)


    if ( stiffyy%is_initialized ) call stiffyy%kill(lun_err)    
    call stiffyy%init(lun_err, &
         nbasis,nbasis,nterm,&
         'csr',&
         is_symmetric=.true.)


    if ( stiffxy%is_initialized ) call stiffxy%kill(lun_err)    
    call stiffxy%init(lun_err, &
         nbasis,nbasis,nterm,&
         'csr',&
         is_symmetric=.False.) 

    
    nnodeincell = this%grid%nnodeincell
    ndim        = this%grid%ambient_dimension
    ldim        = this%grid%logical_dimension      
    ncell       = this%grid%ncell

    !
    ! assign ia and ja of stiffxx
    !
    stiffxx%ia = this%ia_csr
    stiffxx%ja = this%ja_csr
    call stiffxx%build_ind_diag(lun_err)

    !
    ! assign ia and ja stiffxy
    ! 
    stiffxy%ia = this%ia_csr
    stiffxy%ja = this%ja_csr
    call stiffxy%build_ind_diag(lun_err)

    !
    ! assign ia and ja stiffyy
    !
    stiffyy%ia = this%ia_csr
    stiffyy%ja = this%ja_csr
    call stiffyy%build_ind_diag(lun_err)

    !
    ! assembly all coefficients
    !
    stiffxx%coeff = zero
    stiffxy%coeff = zero
    stiffyy%coeff = zero
    !
    do icell=1,ncell
       do j = 1,nnodeincell
          !
          ! get coefficient of the gradient of the local basis functions
          !
          call this%get_gradbase(j,icell,gradbase)
          do i = 1,nnodeincell
             !
             ! get coefficient of the gradient of the local test functions
             !
             call this%get_gradbase(i,icell,gradtest)

	     ! From local to global index 
             ind = this%assembler_csr(i,j,icell)

	     ! Assembly S_xx matrix
             stiffxx%coeff(ind) = stiffxx%coeff(ind) + &
		  cond(icell) * this%grid%size_cell(icell) *&
		  (mu * this%grid%scalar_product(gradbase,gradtest) +&
		  (lambda+mu)*gradbase(1)*gradtest(1))

	     ! Assembly S_yy matrix
             stiffyy%coeff(ind) = stiffyy%coeff(ind) + &
		  cond(icell) * this%grid%size_cell(icell) *&
		  (mu * this%grid%scalar_product(gradbase,gradtest) +&
		  (lambda+mu)*gradbase(2)*gradtest(2))

	     ! Assembly S_xy = S_yx matrix
             stiffxy%coeff(ind) = stiffxy%coeff(ind) + &
                  cond(icell) * this%grid%size_cell(icell) *&
		  (lambda*gradbase(2)*gradtest(1) + &
		  mu*gradbase(1)*gradtest(2)) 
          end do
       end do
    end do

    
  end subroutine build_stiff_saint_venant_block_2D



  
  subroutine assembly_stiff(this, lun_err, storage_system, cond, stiff)
    use Globals
    use SparseMatrix
    implicit none
    type(p1gal),      intent(in   ) :: this
    integer,           intent(in   ) :: lun_err
    character(len=3),  intent(in   ) :: storage_system
    real(kind=double), intent(in   ) :: cond(:)
    type(spmat),       intent(inout) :: stiff

    call this%build_stiff(lun_err, storage_system, cond, stiff)
    
  end subroutine assembly_stiff

  !>-------------------------------------------------------------
  !> Procedure for building the mass matrix
  !> $M(i,j)=\int c(x)\Psi_i \Psi_j$
  !> (procedure private for type p1gal)
  !> The format of the mass matrix can be in ssr or csr
  !>
  !> usage:
  !>     call var%build_mass(lun_err,imem,coeff,mass)
  !>
  !> where:
  !> \param[in   ] lun_err -> integer. I/O Err. msg.unit
  !> \param[in   ] imem    -> integer. storage system sym/nonsym
  !> \param[in   ] coeff   -> real(double). dimension (ncell).
  !>                          cell-wise coeffiecient of mass mat
  !> \param[inout] mass    -> spmat.   Mass matrix
  !<-------------------------------------------------------------
  subroutine build_mass(this,lun_err,storage_system,coeff,mass,nodevar) 
    use Globals
    use SparseMatrix
    implicit none
    class(p1gal),      intent(in   ) :: this
    integer,           intent(in   ) :: lun_err
    character(len=3),  intent(in   ) :: storage_system
    real(kind=double), intent(in   ) :: coeff(this%grid%ncell)
    type(spmat),       intent(inout) :: mass
    real(kind=double), optional, intent(in   ) :: nodevar(this%grid%nnode)
    ! local 
    logical     :: rc
    integer     :: nbasis,nterm
    real(kind=double) :: nodevarloc(this%grid%nnode)
    
    nbasis = this%nbasis

    if ( storage_system .eq. 'ssr' ) nterm=this%nterm_ssr
    if ( storage_system .eq. 'csr' ) nterm=this%nterm_csr

    if ( .not. mass%is_initialized ) then
       call mass%init(lun_err, &
            nbasis,nbasis,nterm,&
            storage_system,&
            is_symmetric=.true.) 
    else
       ! check if matrix has been initilized properly
       if ( .not. mass%check(&
            nbasis,nbasis,nterm,&
            storage_system=storage_system,&
            is_symmetric=.true.) ) then
          rc = IOerr(lun_err, err_val, 'build_mass', &
               ' Matrix Mass has not the proper dimension')
       end if
    end if

    nodevarloc = one
    if (present(nodevar)) nodevarloc = nodevar
    call assembly_mass(this,mass,storage_system,coeff,nodevarloc)
    
  contains
    subroutine assembly_mass(this, mass, storage_system, coeff,nodevar) 
      use Globals
      use SparseMatrix
      implicit none
      class(p1gal),      intent(in   ) :: this
      type(spmat),       intent(inout) :: mass
      character(len=3),  intent(in   ) :: storage_system
      real(kind=double), intent(in   ) :: coeff(this%grid%ncell)
      real(kind=double), intent(in   ) :: nodevar(this%grid%nnode)
      ! local variable
      integer :: i,j,ind,icell,jnode,nnodeincell,nodes(4)
      real(kind=double) :: p_e(4,4), val

      nnodeincell = this%grid%get_nnodes_in_cell(1)
      !
      ! assign ia and ja
      !
      if ( storage_system .eq. 'ssr' ) then
         mass%ia = this%ia_ssr
         mass%ja = this%ja_ssr
      else
         mass%ia = this%ia_csr
         mass%ja = this%ja_csr
      end if
      call mass%build_ind_diag(6)
      
      p_e=one
      do i=1,this%grid%nnodeincell
         p_e(i,i) = 2*one
      end do
      if ( this%grid%nnodeincell .eq. 3)  then
         p_e=p_e/12.0d0
      else
         p_e=p_e/20.0d0
      end if

      !
      ! assembly coeff
      !
      mass%coeff = zero
      if ( storage_system .eq. 'ssr') then
         mass%coeff = zero
         do icell=1,this%grid%ncell
            call this%grid%get_nodes_in_cell(icell, nnodeincell,nodes)
            do i=1,this%grid%nnodeincell
               do j=i,this%grid%nnodeincell
                  ind=this%assembler_ssr(i,j,icell)
                  val = one
                  if(j.eq.i) then
                     jnode = nodes(j)
                     val = nodevar(jnode)
                  end if
                  mass%coeff(ind) = mass%coeff(ind) + &
                       val * &
                       coeff(icell) * p_e(i,j) * this%grid%size_cell(icell)
               end do
            end do
         end do
      else
         mass%coeff = zero
         do icell=1,this%grid%ncell
            call this%grid%get_nodes_in_cell(icell, nnodeincell,nodes)
            do i=1,this%grid%nnodeincell
               do j=1,this%grid%nnodeincell
                  ind=this%assembler_csr(i,j,icell)
                  val = one
                  if(j.eq.i) then
                     jnode = nodes(j)
                     val = nodevar(jnode)
                  end if
                  mass%coeff(ind) = mass%coeff(ind) + &
                       val * &
                       coeff(icell) * p_e(i,j) * this%grid%size_cell(icell)
               end do
            end do
         end do
      end if
         
    end subroutine assembly_mass
  end subroutine build_mass

  !>-------------------------------------------------------------
  !> Procedure for building the mass matrix in lumped form
  !> $M(i,i)=\int c(x) \Psi_i$
  !> (procedure private for type p1gal)
  !>
  !> usage:
  !>     call var%build_mass_lumped(lun_err,mass)
  !>
  !> where:
  !> \param[in   ] lun_err -> integer. I/O Err. msg.unit
  !> \param[inout] mass    -> spmat.   Mass matrix
  !<-------------------------------------------------------------
  subroutine build_mass_lumped(this, lun_err, coeff, mass) 
    use Globals
    use SimpleMatrix
    implicit none
    class(p1gal),      intent(in   ) :: this
    integer,           intent(in   ) :: lun_err
    real(kind=double), intent(in   ) :: coeff(this%grid%ncell)
    type(diagmat),     intent(inout) :: mass
    ! local 
    logical     :: rc
    integer     :: nnode,inode

    nnode = this%grid%nnode

    if ( .not. mass%is_initialized ) &
         call mass%init(lun_err,nnode) 

    call this%int_test(coeff,mass%diagonal)
    
  end subroutine build_mass_lumped

  !>-------------------------------------------------------------
  !> Procedure for building the mass matrix in lumped form
  !> using trapezoidal rule (from nodal coefficients)
  !> $M(i,i)=\sum_T A_T c(x_i) / nnodeincell $
  !> (procedure private for type p1gal)
  !>
  !> usage:
  !>     call var%build_mass_lumped_trap(lun_err,coeff,mass)
  !>
  !> where:
  !> \param[in   ] lun_err -> integer. I/O Err. msg.unit
  !> \param[in   ] coeff   -> real(double). nodal coeff
  !> \param[inout] mass    -> diagmat.   Mass matrix
  !<-------------------------------------------------------------
  subroutine build_mass_lumped_trap(this, lun_err, coeff, mass, nodecoeff) 
    use Globals
    use SimpleMatrix
    implicit none
    class(p1gal),      intent(in   ) :: this
    integer,           intent(in   ) :: lun_err
    real(kind=double), intent(in   ) :: coeff(this%grid%ncell)
    type(diagmat),     intent(inout) :: mass
    real(kind=double), optional, intent(in   ) :: nodecoeff(this%grid%nnode)
    ! local 
    integer     :: nnode,inode,icell,iloc,nodes(4),nnodeincell
    real(kind=double) :: loc(this%grid%nnode)
    
    nnode = this%grid%nnode

    if ( .not. mass%is_initialized ) &
         call mass%init(lun_err,nnode) 

    loc = one
    if(present(nodecoeff)) loc = nodecoeff

    nnodeincell = this%grid%get_nnodes_in_cell(1)
    
    mass%diagonal = zero
    do icell=1,this%grid%ncell
       call this%grid%get_nodes_in_cell(icell, nnodeincell,nodes)
       do iloc = 1,this%grid%nnodeincell 
          inode = nodes(iloc)
          mass%diagonal(inode) = mass%diagonal(inode) +&
                      coeff(icell) * loc(inode) &
                     * this%grid%size_cell(icell)/this%grid%nnodeincell
       end do
    end do

  end subroutine build_mass_lumped_trap

  !>-------------------------------------------------------------
  !> Procedure for building the divergence advection matrix 
  !> $ B(i,j)= - \int_{\Domain} vel \cdot \Grad \Psi_i \Psi_j $
  !> (procedure private for type p1gal)
  !>
  !> usage:
  !>     call 'var'%build_adv(lun_err,vel,mat_adv,[flag_adv])
  !>
  !> where:
  !> \param[in   ] lun_err   -> integer. I/O unit err. msg.
  !> \param[in   ] vel       -> real(double). dimension(logical_dim)
  !> \param[inout] mat_adv   -> spmat. Advection matrix
  !> \param[in   ] flag_adv  -> integer.
  !>                            =1 . default
  !>                            =2 . skew-symmetric form
  !<-------------------------------------------------------------
  subroutine build_adv(this,lun_err,vel,mat_adv,flag_adv)
    use Globals
    use SparseMatrix
    implicit none 
    class(p1gal),      intent(in   ) :: this
    integer,           intent(in   ) :: lun_err
    real(kind=double), intent(in   ) :: &
         vel(this%grid%logical_dimension,this%grid%ncell)
    type(spmat),       intent(inout) :: mat_adv
    integer, optional, intent(in   ) :: flag_adv   
    ! local
    character(len=3) :: storage_system
    logical     :: rc 
    integer     :: nnode,nterm,imem,local_flag

    nnode = this%grid%nnode   

    storage_system = 'csr' 
    nterm=this%nterm_csr

    if ( .not. mat_adv%is_initialized ) then
       call mat_adv%init(lun_err, &
            nnode,nnode,nterm,&
            storage_system,&
            is_symmetric=.false.) 
    else
       if ( .not. mat_adv%check(&
            nnode,nnode,nterm,&
            storage_system,&
            is_symmetric=.false.) ) then
          rc = IOerr(lun_err, err_val, 'build_adv', &
               ' Matrix Mat_Adv has not the proper dimension')
       end if
    end if


    local_flag = 0
    if(present(flag_adv)) local_flag=flag_adv
    if(local_flag.eq.2) then
       call assembly_adv_skew(this,vel,mat_adv)
    else
       call assembly_adv(this,vel,mat_adv)
    end if
    
  contains
    ! Assembly procedure for mat_adv matrix 
    subroutine assembly_adv(this,vel,mat_adv)
      use Globals
      use SparseMatrix
      implicit none
      class(p1gal),      intent(in   ) :: this
      real(kind=double), intent(in   ) :: &
           vel(this%grid%logical_dimension,this%grid%ncell)
      type(spmat),       intent(inout) :: mat_adv
      ! local variables
      integer :: icell,i,j,ind
      integer :: nnodeincell,ndim,ncell,ldim
      real(kind=double) :: x_tria, y_tria, phi_j
      real(kind=double) :: grad_j(this%grid%logical_dimension)
      real(kind=double) :: local_prod
      
      !
      ! assign ia and ja
      !
      mat_adv%ia = this%ia_csr
      mat_adv%ja = this%ja_csr
      call mat_adv%build_ind_diag(6)

      nnodeincell = this%grid%nnodeincell
      ndim        = this%grid%ambient_dimension
      ldim        = this%grid%logical_dimension      
      ncell       = this%grid%ncell

      
      ! Assembly coeff
      mat_adv%coeff = zero
      do icell=1,ncell

         do i = 1,nnodeincell  ! --> test
            do j = 1,nnodeincell  ! --> trial
               ind = this%assembler_csr(j,i,icell)

               !
               ! get coefficient of the gradient of the local trial fun
               !
               call this%get_gradbase(j,icell,grad_j)
               local_prod = dot_product(vel(:,icell),grad_j)

               mat_adv%coeff(ind) = mat_adv%coeff(ind) &
                    + local_prod &
                    * this%grid%size_cell(icell)/nnodeincell
            end do
         end do
      end do      
      
    end subroutine assembly_adv

    ! Assembly procedure for mat_adv matrix 
    subroutine assembly_adv_skew(this,vel,mat_adv)
      use Globals
      use SparseMatrix
      implicit none
      class(p1gal),      intent(in   ) :: this
      real(kind=double), intent(in   ) :: &
           vel(this%grid%logical_dimension,this%grid%ncell)
      type(spmat),       intent(inout) :: mat_adv
      ! local variables
      integer :: icell,i,j,ind
      integer :: nnodeincell,ndim,ncell,ldim
      real(kind=double) :: x_tria, y_tria, phi_j, phi_i, res_i
      real(kind=double) :: grad_i(this%grid%logical_dimension), &
           grad_j(this%grid%logical_dimension)
      real(kind=double) :: local_i, local_j
      
      !
      ! assign ia and ja
      !
      mat_adv%ia = this%ia_csr
      mat_adv%ja = this%ja_csr
      call mat_adv%build_ind_diag(6)

      nnodeincell = this%grid%nnodeincell
      ndim        = this%grid%ambient_dimension
      ldim        = this%grid%logical_dimension      
      ncell       = this%grid%ncell

 
      ! Assembly coeff
      mat_adv%coeff = zero
      do icell=1,ncell
         
         do i = 1,nnodeincell ! -- > test
            do j = 1,nnodeincell ! -- > trial
               ind = this%assembler_csr(j,i,icell)
               
               call this%get_gradbase(i,icell,grad_i)
               call this%get_gradbase(j,icell,grad_j)
               
               local_i = dot_product(vel(:,icell),grad_i)
               local_j = dot_product(vel(:,icell),grad_j)
               
               mat_adv%coeff(ind) = mat_adv%coeff(ind) &
                    !j is the trial solution
                    + local_j*this%grid%size_cell(icell)*0.5/nnodeincell &
                    - local_i*this%grid%size_cell(icell)*0.5/nnodeincell
            end do
         end do
      end do      
      
    end subroutine assembly_adv_skew
    
  end subroutine build_adv


  !>-------------------------------------------------------------
  !> Procedure for building the vector containinf the
  !> integral of the scalar product between a vector and the
  !> gradient of the basis functions.
  !> $ B(i)= - \int_{\Domain} vec \cdot \Grad \Psi_i $
  !> (procedure public for type p1gal)
  !>
  !> usage:
  !>     call 'var'%build_VxGradphi(lun_err,vecin,vecout)
  !>
  !> where:
  !> \param[in   ] vec_in    -> real(double). dimension(logical_dim)
  !> \param[out  ] vec_out   -> 
  !<-------------------------------------------------------------
  subroutine build_VxGradphi(this,vec_in, vec_out)
    use Globals
    implicit none 
    class(p1gal),      intent(in   ) :: this
    real(kind=double), intent(in   ) :: &
         vec_in(this%grid%logical_dimension,this%grid%ncell)
    real(kind=double), intent(out  ) :: vec_out(this%grid%nnode)
    ! local
    logical     :: rc 
    integer     :: ncell, nnodeincell, icell, iloc, inode,i,nodes(4)
    real(kind=double) :: coeff
    real(kind=double) :: gradbase(this%grid%logical_dimension)

    ncell       = this%grid%ncell
    nnodeincell = this%grid%nnodeincell

    vec_out = zero
    do icell = 1, ncell
       call this%grid%get_nodes_in_cell(icell,nnodeincell,nodes(1:nnodeincell))
       do iloc = 1,nnodeincell
          inode = nodes(iloc)
          call this%get_gradbase(iloc,icell,gradbase)

          coeff = dot_product(vec_in(:,icell),gradbase)

          vec_out(inode) = vec_out(inode) + &
               coeff*this%grid%size_cell(icell)
       end do
    end do

  end subroutine build_VxGradphi
  
  
  !>-------------------------------------------------------------
  !> Procedure for building the mass matrix for stabilization term
  !> $ B(i,j)= \int_{\Domain} tau_e c u \vec b\cdot \Grad v $
  !> (procedure public for type p1gal)
  !>
  !> usage:
  !>     call 'var'%build_mass_stab(lun_err,vel,coeff_mass,coeff_diff,
  !>                                delta0,delta1,mass_stab)
  !>
  !> where:
  !> \param[in   ] lun_err      -> integer. I/O unit err. msg.
  !> \param[in   ] vel          -> real(double). dimension(logical,ncell)
  !>                               Advection velocity vectors
  !> \param[in   ] coeff_mass   -> real(double). dimension(ncell)
  !>                               Mass matrix coefficient
  !> \param[in   ] coeff_diff   -> real(double). dimension(ncell)
  !>                               Stiffness matrix coefficient
  !> \param[in   ] delta0       -> real(double). scalar
  !>                               Stabilization parameter
  !> \param[in   ] delta1       -> real(double). scalar
  !>                               Stabilization parameter
  !> \param[inout] mass_stab           -> spmat. Stabilization for
  !>                                      mass matrix
  !>
  !> (uses only csr storage system)
  !<-------------------------------------------------------------
  subroutine build_mass_stab(this,lun_err,vel,coeff_mass,&
       coeff_diff,delta0,delta1,mass_stab)
    use Globals
    use SparseMatrix
    implicit none
    class(p1gal),      intent(in   ) :: this
    integer,           intent(in   ) :: lun_err
    real(kind=double), intent(in   ) :: &
         vel(this%grid%logical_dimension,this%grid%ncell)
    real(kind=double), intent(in   ) :: coeff_mass(this%grid%ncell)
    real(kind=double), intent(in   ) :: coeff_diff(this%grid%ncell)
    real(kind=double), intent(in   ) :: delta0
    real(kind=double), intent(in   ) :: delta1
    type(spmat),       intent(inout) :: mass_stab
    ! local
    character(len=3) :: storage_system
    logical     :: rc 
    integer     :: nnode,nterm

    nnode = this%grid%nnode 

    storage_system = 'csr' 
    nterm=this%nterm_csr
    
    if ( .not. mass_stab%is_initialized ) then
       call mass_stab%init(lun_err, &
            nnode,nnode,nterm,&
            storage_system,&
            is_symmetric=.true.) 
    else
       if ( .not. mass_stab%check(&
            nnode,nnode,nterm,&
            storage_system,&
            is_symmetric=.true.) ) then
          rc = IOerr(lun_err, err_val, 'build_mass_stab', &
               ' Matrix Mass_Stab  has not the proper dimension')
       end if
    end if


    call assembly_mass_adv_supg(this,vel,coeff_mass,&
         coeff_diff,delta0,delta1,mass_stab)

  contains

    ! Assembly procedure for mass_stab matrix 
    subroutine assembly_mass_adv_supg(this,vel,&
         coeff_mass,coeff_diff,delta0,delta1,mass_stab)
      use Globals
      use SparseMatrix
      implicit none
      class(p1gal),      intent(in   ) :: this
      real(kind=double), intent(in   ) :: &
           vel(this%grid%logical_dimension,this%grid%ncell)
      real(kind=double), intent(in   ) :: coeff_mass(this%grid%ncell)
      real(kind=double), intent(in   ) :: coeff_diff(this%grid%ncell)
      real(kind=double), intent(in   ) :: delta0
      real(kind=double), intent(in   ) :: delta1
      type(spmat),       intent(inout) :: mass_stab
      ! local variables
      integer :: icell,i,j,ind
      integer :: nnodeincell,ndim,ncell,ldim
      integer :: inodes(this%grid%nnodeincell)
      real(kind=double) :: x_tria, y_tria, phi_j, phi_i, res_i
      real(kind=double) :: grad_i(this%grid%logical_dimension), &
           grad_j(this%grid%logical_dimension)
      real(kind=double) :: local_i, local_j
      real(kind=double) :: tau_e,norm_v,Pe_h,h_e,tau0,res,adjoint

      ! Lapack temp vars
      integer :: info, ipiv(this%grid%logical_dimension)
      real(kind=double) :: dnrm2
      real(kind=double) :: work(this%grid%logical_dimension)

      !
      ! assign ia and ja
      !
      mass_stab%ia = this%ia_csr 
      mass_stab%ja = this%ja_csr
      call mass_stab%build_ind_diag(6)

      nnodeincell = this%grid%nnodeincell
      ndim        = this%grid%ambient_dimension
      ldim        = this%grid%logical_dimension      
      ncell       = this%grid%ncell

      ! Assembly coeff
      mass_stab%coeff = zero
      do icell=1,ncell

         ! need local element mesh params
         h_e = (this%grid%size_cell(icell))**(one/ldim)
         ! local mesh peclet number
         !norm_v = dnrm2(ldim,vel(:,icell),1)
         norm_v = maxval(abs(vel(:,icell)))
         Pe_h= 0.5*h_e*norm_v/(coeff_diff(icell)+1.d-10)

         if (Pe_h .gt. one) then
            tau0 = delta0*h_e/norm_v
         else
            tau0 = delta1*h_e**2/(coeff_diff(icell)+1.d-10)
         end if
         tau_e = min(tau0,one/(coeff_mass(icell)+1.d-10))

!!$         ! paper: codina_98 - eq. 110
!!$         tau_e = delta1/(four*(coeff_diff(icell)+1.d-10)/h_e**2+two*norm_v/h_e)
!!$         !

         do i = 1,nnodeincell ! test
            do j = 1,nnodeincell ! trial
               ind = this%assembler_csr(j,i,icell)

               call this%get_gradbase(i,icell,grad_i)
               call this%get_gradbase(j,icell,grad_j)
               local_i = dot_product(vel(:,icell),grad_i)
               local_j = dot_product(vel(:,icell),grad_j)

               !barycenter
               phi_i = one/nnodeincell 
               phi_j = one/nnodeincell
               ! phi_j is the trial function
               res   = coeff_mass(icell)*phi_j
               adjoint = local_i !ASGS -coeff_mass(icell)*phi_i
               mass_stab%coeff(ind) = mass_stab%coeff(ind) &
                    + tau_e*res*adjoint * this%grid%size_cell(icell)
            end do
         end do
      end do

    end subroutine assembly_mass_adv_supg

  end subroutine build_mass_stab

  !>-------------------------------------------------------------
  !> Procedure for building the stabilization term for stiffness matrix 
  !> $ B(i,j)= \int_{\Domain} tau_e (\vec b\cdot \Grad u + cu)\vec b\cdot \Grad v $
  !> (procedure public for type p1gal)
  !>
  !> usage:
  !>     call 'var'%build_stiff_stab(lun_err,vel,coeff_mass,coeff_diff,
  !>                                delta0,delta1,mass_stab)
  !>
  !> where:
  !> \param[in   ] lun_err      -> integer. I/O unit err. msg.
  !> \param[in   ] vel          -> real(double). dimension(logical,ncell)
  !>                               Advection velocity vectors
  !> \param[in   ] coeff_mass   -> real(double). dimension(ncell)
  !>                               Mass matrix coefficient
  !> \param[in   ] coeff_diff   -> real(double). dimension(ncell)
  !>                               Stiffness matrix coefficient
  !> \param[in   ] delta0       -> real(double). scalar
  !>                               Stabilization parameter
  !> \param[in   ] delta1       -> real(double). scalar
  !>                               Stabilization parameter
  !> \param[inout] stiff_stab     -> spmat. Stabilization for
  !>                               stiffness matrix
  !>
  !> (uses only csr storage system) 
  !<-------------------------------------------------------------
  subroutine build_stiff_stab(this,lun_err,vel,coeff_mass,&
       coeff_diff,delta0,delta1,stiff_stab)
    use Globals
    use SparseMatrix
    implicit none
    class(p1gal),      intent(in   ) :: this
    integer,           intent(in   ) :: lun_err
    real(kind=double), intent(in   ) :: &
         vel(this%grid%logical_dimension,this%grid%ncell)
    real(kind=double), intent(in   ) :: coeff_mass(this%grid%ncell)
    real(kind=double), intent(in   ) :: coeff_diff(this%grid%ncell)
    real(kind=double), intent(in   ) :: delta0
    real(kind=double), intent(in   ) :: delta1
    type(spmat),       intent(inout) :: stiff_stab
    ! local
    character(len=3) :: storage_system
    logical     :: rc 
    integer     :: nnode,nterm

    nnode = this%grid%nnode 

    storage_system = 'csr'
    nterm=this%nterm_csr

    if ( .not. stiff_stab%is_initialized ) then
       call stiff_stab%init(lun_err, &
            nnode,nnode,nterm,&
            storage_system,&
            is_symmetric=.true.) 
    else
       if ( .not. stiff_stab%check(&
            nnode,nnode,nterm,&
            storage_system,&
            is_symmetric=.true.) ) then
          rc = IOerr(lun_err, err_val, 'build_stiff_stab', &
               ' Matrix Stiff_Stab has not the proper dimension')
       end if
    end if

    call assembly_stiff_supg(this,vel,coeff_mass,&
         coeff_diff,delta0,delta1,stiff_stab)

  contains

    ! Assembly procedure for stiff_adv_supg matrix 
    subroutine assembly_stiff_supg(this,vel,&
         coeff_mass,coeff_diff,delta0,delta1,stiff_stab)
      use Globals
      use SparseMatrix
      implicit none
      class(p1gal),      intent(in   ) :: this
      real(kind=double), intent(in   ) :: &
         vel(this%grid%logical_dimension,this%grid%ncell)
      real(kind=double), intent(in   ) :: coeff_mass(this%grid%ncell)
      real(kind=double), intent(in   ) :: coeff_diff(this%grid%ncell)
      real(kind=double), intent(in   ) :: delta0
      real(kind=double), intent(in   ) :: delta1
      type(spmat),       intent(inout) :: stiff_stab
      ! local variables
      integer :: icell,i,j,ind
      integer :: nnodeincell,ndim,ncell,ldim
      integer :: inodes(this%grid%nnodeincell)
      real(kind=double) :: x_tria, y_tria, phi_j, phi_i, res_i
      real(kind=double) :: grad_i(this%grid%logical_dimension), &
           grad_j(this%grid%logical_dimension)
      real(kind=double) :: local_i, local_j
      real(kind=double) :: tau_e,norm_v,Pe_h,h_e,tau0,res,adjoint

      ! Lapack temp vars
      integer :: info, ipiv(this%grid%logical_dimension)
      real(kind=double) :: work(this%grid%logical_dimension)
      real(kind=double) :: dnrm2

      !
      ! assign ia and ja
      !
      stiff_stab%ia = this%ia_csr 
      stiff_stab%ja = this%ja_csr
      call stiff_stab%build_ind_diag(6)

      nnodeincell = this%grid%nnodeincell
      ndim        = this%grid%ambient_dimension
      ldim        = this%grid%logical_dimension      
      ncell       = this%grid%ncell

      ! Assembly coeff
      stiff_stab%coeff = zero
      do icell=1,ncell

         !need local element mesh params
         h_e = (this%grid%size_cell(icell))**(one/ldim)
  
         !norm_v = dnrm2(ldim,vel(:,icell),1)
         norm_v = maxval(abs(vel(:,icell)))
         !local mesh peclet number
         Pe_h= 0.5*h_e*norm_v/(coeff_diff(icell)+1.d-10)

         if (Pe_h .gt. one) then
            tau0 = delta0*h_e/norm_v
         else
            tau0 = delta1*h_e**2/(coeff_diff(icell)+1.d-10)
         end if
         tau_e = min(tau0,one/(coeff_mass(icell)+1.d-10))

!!$         ! paper: codina_98 - eq. 110
!!$         tau_e = delta0/(four*(coeff_diff(icell)+1.d-10)/h_e**2+two*norm_v/h_e)
!!$         !
         
         do i = 1,nnodeincell ! test
            do j = 1,nnodeincell ! trial
           ind = this%assembler_csr(j,i,icell)

               call this%get_gradbase(i,icell,grad_i)
               call this%get_gradbase(j,icell,grad_j)
               local_i = dot_product(vel(:,icell),grad_i)
               local_j = dot_product(vel(:,icell),grad_j)

               !barycenter
               phi_i = one/nnodeincell 
               phi_j = one/nnodeincell
               ! phi_j is the trial function
               res   = &
                    ! coeff_mass(icell)*phi_j + &
                    local_j                 
                  adjoint = local_i !ASGS -coeff_mass(icell)*phi_i
                  stiff_stab%coeff(ind) = stiff_stab%coeff(ind) &
                       + tau_e*res*adjoint * this%grid%size_cell(icell)
               
            end do
         end do
      end do

    end subroutine assembly_stiff_supg

  end subroutine build_stiff_stab

  !>-------------------------------------------------------------
  !> Procedure for building the stabilization term for rhs
  !> $ l(j)= \int_{\Domain} tau_e f \vec b \cdot \Grad v $
  !> (procedure public for type p1gal)
  !>
  !> usage:
  !>     call 'var'%build_stab_forcing(lun_err,vel,coeff_mass,coeff_diff,
  !>                                delta0,delta1,rhs_forcing,rhs_stab)
  !>
  !> where:
  !> \param[in   ] lun_err      -> integer. I/O unit err. msg.
  !> \param[in   ] vel          -> real(double). dimension(logical,ncell)
  !>                               Advection velocity vectors
  !> \param[in   ] coeff_mass   -> real(double). dimension(ncell)
  !>                               Mass matrix coefficient
  !> \param[in   ] coeff_diff   -> real(double). dimension(ncell)
  !>                               Stiffness matrix coefficient
  !> \param[in   ] delta0       -> real(double). scalar
  !>                               Stabilization parameter
  !> \param[in   ] delta1       -> real(double). scalar
  !>                               Stabilization parameter
  !> \param[in   ] rhs_forcing  -> real(double). dimension(nnode)
  !>                               Rhs nodal forcing
  !> \param[inout] rhs_stab     -> real(double). dimension(nnode)
  !>                               Rhs nodal stabilizarion term
  !>
  !> (uses only csr storage system) 
  !<-------------------------------------------------------------
  subroutine build_stab_forcing(this,vel,coeff_mass,coeff_diff,&
       delta0,delta1,rhs_nodal_forcing,rhs_stab)
    use Globals
    use SparseMatrix
    implicit none
    class(p1gal),      intent(in   ) :: this
    real(kind=double), intent(in   ) :: &
           vel(this%grid%logical_dimension,this%grid%ncell)
    real(kind=double), intent(in   ) :: coeff_mass(this%grid%ncell)
    real(kind=double), intent(in   ) :: coeff_diff(this%grid%ncell)
    real(kind=double), intent(in   ) :: delta0
    real(kind=double), intent(in   ) :: delta1
    real(kind=double), intent(in   ) :: rhs_nodal_forcing(this%grid%nnode)
    real(kind=double), intent(inout) :: rhs_stab(this%grid%nnode)
    ! local variables
    integer :: icell,i,inode
    integer :: nnodeincell,ndim,ncell,ldim,nodes(4)
    integer :: inodes(this%grid%nnodeincell)
    real(kind=double) :: x_tria, y_tria, phi_j, phi_i, res_i
    real(kind=double) :: grad_i(this%grid%logical_dimension), &
         grad_j(this%grid%logical_dimension)
    real(kind=double) :: local_i, local_j
    real(kind=double) :: tau_e,norm_v,Pe_h,h_e,tau0,res,adjoint
    ! Lapack temp vars
    integer :: info, ipiv(this%grid%logical_dimension)
    real(kind=double) :: work(this%grid%logical_dimension)
    
    
    nnodeincell = this%grid%nnodeincell
    ndim        = this%grid%ambient_dimension
    ldim        = this%grid%logical_dimension      
    ncell       = this%grid%ncell

    ! Assembly coeff
    rhs_stab = zero
    do icell=1,ncell
       
       ! need local element mesh params
       h_e = (this%grid%size_cell(icell))**(one/ldim)
       ! local mesh peclet number
       !norm_v = dnrm2(ldim,vel(:,icell),1)
       norm_v = maxval(abs(vel(:,icell)))

       !local mesh peclet number
       Pe_h= 0.5*h_e*norm_v/(coeff_diff(icell)+1.d-10)

       if (Pe_h .gt. one) then
          tau0 = delta0*h_e/norm_v
       else
          tau0 = delta1*h_e**2/(coeff_diff(icell)+1.d-10)
       end if
       tau_e = min(tau0,one/(coeff_mass(icell)+1.d-10))

!!$       ! paper codina_98 : eq. 110
!!$       tau_e = delta0/(four*(coeff_diff(icell)+1.d-10)/h_e**2+two*norm_v/h_e)
!!$       !
       
       !since the velocity and test function gradients are constant,
       ! just average the nodal rhs functions to get an element average
       res = 0.d0

       call this%grid%get_nodes_in_cell(icell,nnodeincell,nodes(1:nnodeincell))
       do i = 1,nnodeincell
          inode = nodes(i)
          res = res + &
               rhs_nodal_forcing(inode)/this%basis_integral(inode)/nnodeincell
       end do

       
       do i = 1,nnodeincell !loop over test functions
          
          inode = nodes(i)

          call this%get_gradbase(i,icell,grad_i)
          local_i = dot_product(vel(:,icell),grad_i)
          
          adjoint = local_i !ASGS-coeff_mass(icell)*phi_i

          rhs_stab(inode)= rhs_stab(inode) &
               + tau_e*res*adjoint*this%grid%size_cell(icell)
       end do
    end do

  end subroutine build_stab_forcing

  !!!(EB - 1lug2020 - definire un get_taue_stab)
  
  !>-------------------------------------------------------------
  !> Procedure for evaluation of the gradient $\nabla u_h$
  !> of a function in $P1(\Tau(\Omega))$ in a cell 'icell'
  !> (procedure public for type p1gal)
  !>
  !> usage:
  !>     call "var"%eval_gradcell(this,icell,pot,grad)
  !>
  !> where:
  !> \param[in] icell  -> integer. Cell index 
  !> \param[in] pot    -> real dimension(nnodeincell) 
  !>                        Coeff. of $u_h\in P1_h$ on cell
  !> \param[in] grad   -> real dimension(logical_dim). 
  !>                         grad(u_h) $u_h\in P1_h$ on cell
  !<-------------------------------------------------------------
  subroutine eval_gradcell(this,icell,pot,grad)
    use Globals
    implicit none
    class(p1gal),      intent(in ) :: this
    integer,           intent(in ) :: icell
    real(kind=double), intent(in ) :: pot(this%grid%nnodeincell)
    real(kind=double), intent(out) :: grad(this%grid%logical_dimension)
    !local array
    integer :: iloc, i,ldim
    real(kind=double) :: ddot
    real(kind=double) :: potnode
    real(kind=double) :: gradbase(this%grid%logical_dimension)
    
    ldim=this%grid%logical_dimension

    grad = zero
    do iloc = 1, this%grid%nnodeincell
       call this%get_gradbase(iloc,icell,gradbase)
       do i = 1,ldim
          grad(i) = grad(i) + pot(iloc) * gradbase(i)
       end do
    end do

  end subroutine eval_gradcell

  !>-------------------------------------------------------------
  !> Procedure for evaluation of the gradient $\nabla u_h$
  !> of a function in $P1(\Tau(\Omega))$ in all the cells
  !> (procedure public for type p1gal)
  !>
  !> usage:
  !>     call eval_grad(this,pot,grad)
  !>
  !> where:
  !> \param[in] pot    -> real array. Coeff. of   $u_h\in P1_h$
  !> \param[in] grad   -> real dimension(logical_dim,ncell). 
  !>                      grad(u_h) $u_h\in P1_h$
  !<-------------------------------------------------------------
  subroutine eval_grad(this,pot,grad)
    use Globals
    implicit none
    class(p1gal),      intent(in ) :: this
    real(kind=double), intent(in ) :: pot(this%nbasis)
    real(kind=double), intent(out) :: &
         grad(this%grid%logical_dimension,this%ncell)
    !local array
    integer :: icell
    integer :: nnodeincell,nodes(4)
    
   
    nnodeincell = this%grid%get_nnodes_in_cell(1)

    do icell=1,this%ncell
       !u(x,y)_{|T_{icell}}=\sum_{i=1,3}u_i (a_i + b_i x + c_i y)

       ! grad_x_{|T_{icell}}=\sum_{i=1,3}u_i b_{i}
       call this%grid%get_nodes_in_cell(icell,nnodeincell,nodes)
       call  this%eval_gradcell(icell,&
            pot(nodes(1:nnodeincell)),&
            grad(:,icell) )
       
    end do
  end subroutine eval_grad

  !>-------------------------------------------------------------
  !> Procedure for evaluation of euclidean norm of
  !> the gradient over a cell
  !> of function in $P1(\Tau(\Omega))$
  !> (procedure public for type p1gal)
  !>
  !> usage:
  !>     call eval_norm_grad(this,pot,nrm_grad)
  !>
  !> where:
  !> \param[in] pot       -> real array. Coeff. of $u_h$
  !> \param[in] nrm_grad -> real array. \sqrt(grad_x(u_h)^2+grad_y(u_h)^2)
  !<-------------------------------------------------------------
  subroutine eval_nrm_grad(this,pot,nrm_grad)
    use Globals
    implicit none
    class(p1gal),      intent(in   ) :: this
    real(kind=double), intent(in   ) :: pot(this%nbasis)
    real(kind=double), intent(inout) :: nrm_grad(this%ncell)
    !local array
    integer :: icell
    integer :: ldim, nnodeincell,nodes(4)
    real(kind=double) :: gradcell(this%grid%logical_dimension)
    real(kind=double) :: dnrm2
    
    nnodeincell = this%grid%get_nnodes_in_cell(1)
    ldim        = this%grid%logical_dimension

    do icell=1, this%grid%ncell
       ! u(x,y,z)_{|T_{icell}}=
       ! \sum_{i=1,nnodeincell} u_i (a_i + b_i*x + c_i*y+d_i*z)

       ! grad_{|T_{icell}}= 
       ! \sum_{i=1,nnodeincell} u_i (b_{i},c_{i},d_{i})
       call this%grid%get_nodes_in_cell(icell,nnodeincell,nodes(1:nnodeincell))

       call  this%eval_gradcell(icell,&
            pot(nodes(1:nnodeincell)),&
            gradcell)

       nrm_grad(icell) = dnrm2(ldim,gradcell,1) 

    end do
  end subroutine eval_nrm_grad

  !>-------------------------------------------------------------
  !> Procedure for evaluation of the strain energy density
  !> ! $\mu|\epsilon (u)|^2 + \frac{\lambda}{2}|\div(u)|^2$
  !> over a cell of function in $P1(\Tau(\Omega))$
  !> (procedure public for type p1gal)
  !>
  !> usage:
  !>     call 'var'%eval_strain_energy(this,pot,nrm_grad)
  !>
  !> where:
  !> \param[in] mu		-> First Lame' parameter (real variable)
  !> \param[in] lambda	-> Second Lame' parameter (real variable)
  !> \param[in] potx    -> Coefficients of $u^1_h$. 
  !>								Real array of dim nbasis. 
  !> \param[in] poty    -> Coefficients of $u^2_h$. 
  !>								Real array of dim nbasis. 
  !> \param[in] energy  -> Strain energy density for each cell
  !>								of the grid. Real array of dim ncell
  !<-------------------------------------------------------------
  subroutine eval_strain_energy(this,mu,lambda,energy,potx,poty,potz)

    use Globals
    implicit none

	 ! Input and Output variables
    class(p1gal),      intent(in   ) :: this
    real(kind=double), intent(in   ) :: mu
	 real(kind=double), intent(in   ) :: lambda
    real(kind=double), intent(inout) :: energy(this%ncell)
    real(kind=double), intent(in   ) :: potx(this%nbasis)
    real(kind=double), intent(in   ) :: poty(this%nbasis)
    real(kind=double), optional, intent(in   ) :: potz(this%nbasis)

    ! Local variables
    integer :: icell, ldim, nnodeincell, ncell,nodes(4)
    real(kind=double) :: exx, eyy, exy, eyx, exz, ezx, ezy, eyz, ezz
    real(kind=double) :: gradcell(this%grid%logical_dimension,&
         this%grid%logical_dimension)

    ncell       = this%grid%ncell
    nnodeincell = this%grid%get_nnodes_in_cell(1)
    ldim        = this%grid%logical_dimension

    select case(ldim)
    case(2)

       ! Loop over the triangles
       do icell = 1,ncell
          ! Each component of u(x,y,z) = (u1(x,y,z),u2(x,y,z),u3(x,y,z)) 
          ! restricted to cell T_{icell} can be written as

          ! u(x,y,z)_{|T_{icell}}=
          ! \sum_{i=1,nnodeincell} u_i (a_i + b_i*x + c_i*y+d_i*z)

          ! The gradient is 
          ! grad_{|T_{icell}}= 
          ! \sum_{i=1,nnodeincell} u_i (b_{i},c_{i},d_{i})

          ! The strain tensor is 
          ! epsilon(u) = 1/2*(grad(u) + grad(u)^T)

          call this%grid%get_nodes_in_cell(icell, nnodeincell,nodes)
          
          ! Compute gradient of u1
          call  this%eval_gradcell(icell,&
               potx(nodes(1:nnodeincell)),&
               gradcell(1,1:ldim))

          ! Compute gradient of u2
          call  this%eval_gradcell(icell,&
               poty(nodes(1:nnodeincell)),&
               gradcell(2,1:ldim))

          ! Strain tensor components 
          exx = gradcell(1,1)
          eyy = gradcell(2,2)
          exy = 0.5*(gradcell(1,2)+gradcell(2,1))
          eyx = exy

          ! Compute strain energy density for icell
          energy(icell) = mu*(exx**2+eyy**2+exy**2+eyx**2)+&
               0.5*lambda*(exx+eyy)**2
       end do	

    case(3)

       ! Loop over tetrahedra
       do icell = 1,ncell
          ! get nodes
          call this%grid%get_nodes_in_cell(icell, nnodeincell,nodes(1:nnodeincell))
          
          ! Compute gradient of u1
          call  this%eval_gradcell(icell,&
               potx(nodes(1:nnodeincell)),&
               gradcell(1,1:ldim))

          ! Compute gradient of u2
          call  this%eval_gradcell(icell,&
               poty(nodes(1:nnodeincell)),&
               gradcell(2,1:ldim))

          ! Compute gradient of u3
          call  this%eval_gradcell(icell,&
               potz(nodes(1:nnodeincell)),&
               gradcell(3,1:ldim))

          ! Strain tensor components 
          exx = gradcell(1,1)
          eyy = gradcell(2,2)
          ezz = gradcell(3,3)
          exy = 0.5*(gradcell(1,2)+gradcell(2,1))
          exz = 0.5*(gradcell(1,3)+gradcell(3,1))
          eyz = 0.5*(gradcell(3,2)+gradcell(2,3))
          eyx = exy
          ezx = exz
          ezy = eyz

          ! Compute strain energy density for icell
          energy(icell) = mu*(exx**2 + eyy**2 + ezz**2 + exy**2 + eyx**2 + &
               eyz**2 + ezy**2 + exz**2 + ezx**2) + &
               0.5*lambda*(exx+eyy+ezz)**2
       end do	

    end select

  end subroutine eval_strain_energy

!>-------------------------------------------------------------
  !> Procedure for evaluation of the strain energy density
  !> ! $\mu|\epsilon (u)|^2 + \frac{\lambda}{2}|\div(u)|^2$
  !> over a cell of function in $P1(\Tau(\Omega))$
  !> (procedure public for type p1gal)
  !>
  !> usage:
  !>     call 'var'%eval_strain_energy(this,pot,nrm_grad)
  !>
  !> where:
  !> \param[in] mu		-> First Lame' parameter (real variable)
  !> \param[in] lambda	-> Second Lame' parameter (real variable)
  !> \param[in] potx    -> Coefficients of $u^1_h$. 
  !>								Real array of dim nbasis. 
  !> \param[in] poty    -> Coefficients of $u^2_h$. 
  !>								Real array of dim nbasis. 
  !> \param[in] energy  -> Strain energy density for each cell
  !>								of the grid. Real array of dim ncell
  !<-------------------------------------------------------------
  subroutine eval_strain(this,mu,lambda,potx,poty,strain)

    use Globals
    implicit none

	 ! Input and Output variables
    class(p1gal),      intent(in   ) :: this
    real(kind=double), intent(in   ) :: mu
	 real(kind=double), intent(in   ) :: lambda
    real(kind=double), intent(in   ) :: potx(this%nbasis)
    real(kind=double), intent(in   ) :: poty(this%nbasis)
    real(kind=double), intent(inout) :: strain(&
         this%grid%logical_dimension,&
         this%grid%logical_dimension,&
			this%ncell)

    ! Local variables
    integer :: icell, ldim, nnodeincell, ncell,nodes(4)
    real(kind=double) :: exx, eyy, exy, eyx
    real(kind=double) :: gradcell(this%grid%logical_dimension,&
         this%grid%logical_dimension)

    ncell       = this%grid%ncell
    nnodeincell = this%grid%nnodeincell
    ldim        = this%grid%logical_dimension

    ! Loop over the elements 
    do icell = 1,ncell
       ! Each component of u(x,y,z) = (u1(x,y,z),u2(x,y,z),u3(x,y,z)) 
       ! restricted to cell T_{icell} can be written as

       ! u(x,y,z)_{|T_{icell}}=
       ! \sum_{i=1,nnodeincell} u_i (a_i + b_i*x + c_i*y+d_i*z)

       ! The gradient is 
       ! grad_{|T_{icell}}= 
       ! \sum_{i=1,nnodeincell} u_i (b_{i},c_{i},d_{i})

       ! The strain tensor is 
       ! epsilon(u) = 1/2*(grad(u) + grad(u)^T)

       call this%grid%get_nodes_in_cell(icell, nnodeincell,nodes(1:nnodeincell))
       
       ! Compute gradient of u1
       call  this%eval_gradcell(icell,&
            potx(nodes(1:nnodeincell)),&
            gradcell(1,1:ldim))

		 ! Compute gradient of u2
       call  this%eval_gradcell(icell,&
            poty(nodes(1:nnodeincell)),&
            gradcell(2,1:ldim))
       
       ! Strain tensor components 
       exx = gradcell(1,1)
       eyy = gradcell(2,2)
       exy = 0.5*(gradcell(1,2)+gradcell(2,1))
       eyx = exy

       strain(1,1,icell) = exx
       strain(2,2,icell) = eyy
       strain(1,2,icell) = exy
       strain(2,1,icell) = exy
       
    end do	

  end subroutine eval_strain


  !>-------------------------------------------------------------
  !> Procedure for evaluation of flux $- K \nabla u_h$ over a cell
  !> of function in $P1(\Tau(\Omega))$
  !> (procedure public for type p1gal)
  !>
  !> usage:
  !>     call "var"%eval_fluxcell(this,icell,cond,pot,flux)
  !>
  !> where:
  !> \param[in] icell    -> integer. Cell index 
  !> \param[in   ] cond  -> real(double).
  !>                        assumed dimension:
  !>                        - ncell   = scalar value
  !>                        - 3*ncell = 2D-anisotropic
  !>                                  (c11,c21,c22)x(1,..,ncell)
  !>                        - 6*ncell = 3D-anisotropic
  !>                                  (c11,c21,c22,c31,c32,c33)
  !>                                               x(1,..,ncell)
  !> \param[in] pot    -> real dimension(nnodeincell) 
  !>                      Coeff. of $u_h\in P1_h$ on cell
  !> \param[in] flux   -> real dimension(logical_dim). 
  !>                         $- K \nabla u_h$ on cell
  !<-------------------------------------------------------------
  subroutine eval_fluxcell(this,icell,cond,pot,flux)
    use Globals
    implicit none
    class(p1gal),      intent(in ) :: this
    integer,           intent(in ) :: icell
    real(kind=double), intent(in ) :: &
         cond(this%grid%logical_dimension*&
           (this%grid%logical_dimension+1)/2&
           *this%grid%ncell)
    real(kind=double), intent(in ) :: pot(this%grid%nnodeincell)
    real(kind=double), intent(out) :: flux(this%grid%logical_dimension)
    !local array
    integer :: iloc, i,ldim,ncell
    real(kind=double) :: grad(this%grid%logical_dimension)
    real(kind=double) :: cond_loc(this%grid%logical_dimension,this%grid%logical_dimension)
    
    ldim = this%grid%logical_dimension
    ncell = this%grid%ncell

    call this%eval_gradcell(icell,pot,grad)   
    cond_loc = get_cond_loc(ncell,ldim,icell,cond)
    
    flux = - matmul(cond_loc,grad)

  end subroutine eval_fluxcell

  !>-------------------------------------------------------------
  !> Procedure for evaluation of flux $- K \nabla u_h$ 
  !> of function in $P1(\Tau(\Omega))$ in all the cells
  !> (procedure public for type p1gal)
  !>
  !> usage:
  !>     call eval_flux(this,condpot,grad)
  !>
  !> where:
  !> \param[in   ] cond  -> real(double).
  !>                        assumed dimension:
  !>                        - ncell   = scalar value
  !>                        - 3*ncell = 2D-anisotropic
  !>                                  (c11,c21,c22)x(1,..,ncell)
  !>                        - 6*ncell = 3D-anisotropic
  !>                                  (c11,c21,c22,c31,c32,c33)
  !>                                               x(1,..,ncell)
  !> \param[in] pot    -> real dimension(nnodeincell) 
  !>                      Coeff. of $u_h\in P1_h$ on cell
  !> \param[in] flux   -> real dimension(logical_dim). 
  !>                         $- K \nabla u_h$ on cell
  !<-------------------------------------------------------------
  subroutine eval_flux(this,cond,pot,flux,vscal)
    use Globals
    implicit none
    class(p1gal),      intent(in ) :: this
    real(kind=double), intent(in ) :: &
         cond(this%grid%logical_dimension*&
         (this%grid%logical_dimension+1)/2&
         *this%grid%ncell)
    real(kind=double), intent(in ) :: pot(this%nbasis)
    real(kind=double), intent(out) :: flux(this%grid%logical_dimension,this%ncell)
    real(kind=double), optional, intent(in) :: vscal(this%grid%ncell)
    !local array
    integer :: icell
    integer :: nnodeincell,nodes(4)
    real(kind=double) :: vscal_loc(this%grid%ncell)
    
    
    nnodeincell = this%grid%nnodeincell

    vscal_loc = one
    if(present(vscal)) vscal_loc = vscal
    
    do icell=1,this%ncell
       call this%grid%get_nodes_in_cell(icell, nnodeincell,nodes(1:nnodeincell))
       call  this%eval_fluxcell(icell,&
            cond,&
            pot(nodes(1:nnodeincell)),&
            flux(:,icell) )
       flux(:,icell) = flux(:,icell)*vscal_loc(icell)
       
    end do
  end subroutine eval_flux

  !>-------------------------------------------------------------
  !> Procedure for building volume related to each node
  !> (procedure private for type p1gal member basis_integral,
  !> used in init)
  !>
  !> usage:
  !>     call 'var'build_basis_integral(lun_err)
  !>
  !> where:
  !> \param[in ] lun_err -> integer. Logic unit for error message
  !<-------------------------------------------------------------
  subroutine build_basis_integral(this, lun_err)
    use Globals
    implicit none
    class(p1gal),      intent(inout) :: this
    integer,           intent(in   ) :: lun_err
    !local variable
    logical :: rc
    integer :: res
    integer :: inode,icell,iloc
    integer :: ncell,nnodeincell,nodes(4)
    real(kind=double) :: basefun_on_bar


    allocate(this%basis_integral(this%grid%nnode),stat=res)
    if(res .ne. 0) rc = IOerr(lun_err, err_alloc, 'build_basis_integral', &
         ' type p1gal member basis_integral',res)    

    ncell       = this%grid%ncell
    nnodeincell = this%grid%nnodeincell

    basefun_on_bar = one / nnodeincell 

    this%basis_integral = zero
    do icell=1,this%grid%ncell
       call this%grid%get_nodes_in_cell(icell, nnodeincell,nodes(1:nnodeincell))
       do iloc=1,nnodeincell
          inode = nodes(iloc)
          this%basis_integral(inode) = this%basis_integral(inode) + &
               this%grid%size_cell(icell)*basefun_on_bar
       end do
    end do

  end subroutine build_basis_integral


  !>-------------------------------------------------------------
  !> Part of the static constructor
  !> (procedure private for type p1gal,used in init: 
  !> Construction of integer pointer ia_ssr and ja_ssr
  !>
  !> usage:
  !>     call 'var'%build_iaja_ssr(lun_err,n1,grid)
  !>
  !> where:
  !> \param[in ] lun_err -> integer. logic unit for error message   
  !> \param[in ] n1      -> integer. number bigger than the maximum
  !>                        number of tetrahedrons in node. 
  !>                        defined in init_p1gal, generally 60
  !> \param[in] grid    -> type(mesh). Data of the mesh
  !<-------------------------------------------------------------
  subroutine build_iaja_ssr(this,lun_err,n1,grid)
      use Globals
      implicit none
      class(p1gal), intent(inout) :: this
      integer,      intent(in   ) :: lun_err
      integer,      intent(in   ) :: n1
      class(abs_simplex_mesh), intent(in ) :: grid

      ! local variables
      integer :: i,j,k,l,m,iii,kk,kkk,ind,mm,mcontr
      integer :: n,nt,nterm,imax,nnodeincell
      integer :: i1(4),i2(4)
      integer, allocatable :: ja_tmp(:)
      integer :: res
      logical :: rc

      n=this%grid%nnode
      nt=this%grid%ncell
      imax=2147483647
      nterm=n1*n

      ! instantiation and construction ia_ssr and ja_tmp
      allocate(this%ia_ssr(n+1),stat=res)
      if(res .ne. 0) rc = IOerr(lun_err, err_alloc, 'init_p1gal', &
           '  type p1gal member ia_ssr',res)
      allocate(ja_tmp(nterm),stat=res)
      if(res .ne. 0) rc = IOerr(lun_err, err_alloc, 'init_p1gal', &
           ' local array ja_tmp',res)
      
      ! fissa gli elementi diagonali a distanza costante N1
      ja_tmp=0
      ja_tmp(1)=1
      do k=1,nterm-1
         if (k/n1*n1 .eq. k) ja_tmp(k+1)=k/n1+1
      end do

      ! same number 
      nnodeincell = this%grid%get_nnodes_in_cell(1)
      
      do 400 k=1,nt
         ! get the list of node in 
         call this%grid%get_nodes_in_cell(k,nnodeincell, i1)
         
         ! ordina i nodi all'interno dell'elemento in senso crescente
         call isort(nnodeincell,i1)
         
         ! genero il vettore ja_tmp
         do 6 i=1,nnodeincell-1
            j=i+1
            do 7 l=j,nnodeincell
               m=n1*(i1(i)-1)+l-j+2
               mcontr=n1*i1(i)
    9          if(i1(l)-ja_tmp(m))8,7,11
   11          if(ja_tmp(m).eq.0)go to 10
               m=m+1
               if(m-mcontr.ge.0)go to 99
               go to 9
   10          ja_tmp(m)=i1(l)
               go to 7
    8          mm=m
   18          mm=mm+1
               if(mm-mcontr.ge.0) go to 99
               if(ja_tmp(mm))18,13,18
   13          ja_tmp(mm)=ja_tmp(mm-1)
               mm=mm-1
               if(mm.gt.m)go to 13
               ja_tmp(m)=i1(l)
    7       end do ! end do cycle 7
    6    end do   ! end do cycle 6
  400 end do      ! end do cycle 400 (do k=1,nt)

      ! costrisco il vettore ia_ssr

      this%ia_ssr(1)=1
      m=1
      j=1
      do 20 k=1,nterm,n1
         do 21 i=1,n1
            if(ja_tmp(k+i-1).eq.0)go to 21
            m=m+1
   21    continue ! end do cycle 21
         j=j+1
         this%ia_ssr(j)=m
   20 continue ! end do cycle 20

      ! compatta il vettore ja_tmp eliminando gli zeri

      m=0
      do 14 k=1,nterm
         if(ja_tmp(k).eq.0) go to 14
         m=m+1
         ja_tmp(m)=ja_tmp(k)
14    end do  ! end do cycle 14
      nterm=m
      
      this%nterm_ssr = nterm
      
      ! instatiation and construction ja_ssr
      
      allocate(this%ja_ssr(this%nterm_ssr),stat=res)
      if(res .ne. 0) rc = IOerr(lun_err, err_alloc, 'init_p1gal', &
           ' type p1gal member ja_ssr',res)
      
      this%ja_ssr = ja_tmp(1:this%nterm_ssr)
      
      
      return
   99 iii=mcontr/n1
      write(lun_err,101)iii,k
  101 format(1x,'riga = ',i6,' tetraedro = ',i6,'  aumentare n1 ')
      

      ! deallocation of the local variable
      deallocate(ja_tmp,stat=res)
      if(res .ne. 0) rc = IOerr(lun_err, err_dealloc, 'init_p1gal', &
           ' local arrays ja_tmp',res)

            

  end subroutine build_iaja_ssr


  !>-------------------------------------------------------------
  !> Part of the static constructor
  !> (procedure private for type p1gal member assembler, used in init:
  !> allocation and construction)
  !>
  !> usage:
  !>     call build_assembler_ssr(lun_err, &
  !>          nnode, ncell, nnodeincell, nterm, &
  !>          ia ,ja, triang, assembler)
  !>
  !> where:
  !> \param[in ] nnode       -> integer. Number of Nodes
  !> \param[in ] ncell       -> integer. Number of triangles
  !> \param[in ] nnodeincell -> integer. Number of node for each cell
  !> \param[in ] nterm       -> integer. Number of non-zero element
  !> \param[in ] ia          -> integer(N+1) : Pointer of diagonal element
  !> \param[in ] ja          -> integer(nterm) : Pointer to column index of 
  !> \param[in ] triang      -> integer(nnodeincel+1,ncell) : 
  !>                              Nodes in triangle + material 
  !> \par-ma[out] assembler  -> integer(3,3,ncell) : Pointer  
  !>
  !> Note this produced the asembler for A^T A where A iis the sparse matrix
  !> with ncell ows and nnode column and 
  !> $A(i,j)=1$ if j\in nodes(i) 
  !> which is given by topol
  !<-------------------------------------------------------------
  subroutine build_assembler_ssr(nnode, ncell, nnodeincell, nterm, &
       ia ,ja, assembler,grid)
    use Globals
    implicit none
    integer, intent(in )  :: nnode, ncell, nnodeincell, nterm
    integer, intent(in )  :: ia(nnode+1), ja(nterm)
    integer, intent(out) :: assembler(nnodeincell,nnodeincell,ncell)
    class(abs_simplex_mesh) :: grid
    ! local variables
    integer :: icell,i,j,ii,jj,kk,ind
    integer :: inode(4) ! set dimension to 4 which is the maximum used
    integer :: start,tobefound

    ! construction of assembler
    assembler=0
    do icell=1,ncell
       call grid%get_nodes_in_cell(icell,nnodeincell,inode(1:nnodeincell))
       do i=1,nnodeincell
          ii=inode(i)
          do j=i,nnodeincell
             jj=inode(j)
             start    =ii
             tobefound=jj
             if (tobefound .lt. start ) then
                ! swap indeces
                kk        = start
                start     = tobefound
                tobefound = kk
             end if
             ind=ia(start)
             do while ( ja(ind) .ne. tobefound )
                ind=ind+1
             end do
             assembler(j,i,icell)=ind
          end do
       end do
    end do
  end subroutine build_assembler_ssr

  !>-------------------------------------------------------------
  !> Part of the static constructor
  !> (procedure private for type p1gal,used in init: 
  !> Construction of integer pointer ia and ja for CSR
  !> 
  !>
  !> usage:
  !>     call 'var'%build_iaja_csr(lun_err,n1,grid)
  !>
  !> where:
  !> \param[in ] lun_err -> integer. logic unit for error message   
  !> \param[in ] n1      -> integer. number bigger than the maximum
  !>                        number of tetrahedrons in node. 
  !>                        defined in init_p1gal, generally 60
  !> \param[in] grid    -> type(mesh). Data of the mesh
  !<-------------------------------------------------------------
  subroutine build_iaja_csr(this,lun_err,n1,grid)
      use Globals
      implicit none
      class(p1gal), intent(inout) :: this
      integer,      intent(in   ) :: lun_err
      integer,      intent(in   ) :: n1
      class(abs_simplex_mesh), intent(in ) :: grid


      ! local variables
      integer :: i,j,k,l,m,iii,kk,kkk,mm,mcontr
      integer :: n,nt,nterm,imax,ncell,nnodeincell
      integer :: i1(4),i2(4)
      integer, allocatable :: ja_tmp(:)
      integer :: res
      logical :: rc

      n=this%grid%nnode
      ncell=this%grid%ncell
      nnodeincell=this%grid%nnodeincell
      imax=2147483647
      nterm=n1*n

      ! instantiation and construction ia_csr and ja_tmp
      allocate(this%ia_csr(n+1),stat=res)
      if(res .ne. 0) rc = IOerr(lun_err, err_alloc, 'build_iaja_csr', &
           '  type p1gal member ia_csr',res)
      allocate(ja_tmp(nterm),stat=res)
      if(res .ne. 0) rc = IOerr(lun_err, err_alloc, 'build_iaja_csr', &
           ' local array ja_tmp',res)
      
      ! fissa gli elementi diagonali a distanza costante N1
      ja_tmp = 0

      ! same number of cells
      nnodeincell = this%grid%get_nnodes_in_cell(1)
      do 400 k=1,ncell
         ! local copy
         ! get the list of node in 
         call this%grid%get_nodes_in_cell(k,nnodeincell, i1)

         ! sort node in incresing order
         call isort(nnodeincell,i1)
         !
         ! create work array ja_tmp
         !
         DO 6 I=1,nnodeincell
            DO 7 L=1,nnodeincell
               M=N1*(I1(I)-1)+L
               MCONTR=N1*I1(I)
9              IF(I1(L)-ja_tmp(M))8,7,11
11             IF(ja_tmp(M).EQ.0)GO TO 10
               M=M+1
               IF(M-MCONTR.GE.0)GO TO 99
               GO TO 9
10             ja_tmp(M)=I1(L)
               GO TO 7
8              MM=M
18             MM=MM+1
               IF(MM-MCONTR.GE.0) GO TO 99
               IF(ja_tmp(MM))18,13,18
13             ja_tmp(MM)=ja_tmp(MM-1)
               MM=MM-1
               IF(MM.GT.M)GO TO 13
               ja_tmp(M)=I1(L)
7           END DO
6        END DO
400   END do

      !
      ! costrisco il vettore ia_csr
      !
      this%ia_csr(1)=1
      m=1
      j=1
      do k=1,nterm,n1
         do i=1,n1
            if(ja_tmp(k+i-1).ne.0) m=m+1
         end do  
         j=j+1
         this%ia_csr(j)=m
      end do

      ! clean vector ja_tmp removing zeros 
      m=0
      do k=1,nterm
         if(ja_tmp(k).ne.0) then
            m=m+1
            ja_tmp(m)=ja_tmp(k)
         end if
      end do 
      nterm=m

      this%nterm_csr = nterm
         
      ! instatiation and construction ja_csr
      
      allocate(this%ja_csr(this%nterm_csr),stat=res)
      if(res .ne. 0) rc = IOerr(lun_err, err_alloc, 'build_iaja_csr', &
           ' type p1gal member ja_csr',res)

      this%ja_csr = ja_tmp(1:this%nterm_csr)

      return
   99 iii=mcontr/n1
      write(lun_err,101)iii,k
  101 format(1x,'riga = ',i6,' tetraedro = ',i6,'  aumentare n1 ')
      stop

      ! deallocation of the local variable
      deallocate(ja_tmp,stat=res)
      if(res .ne. 0) rc = IOerr(lun_err, err_dealloc, 'build_iaja_csr', &
           ' local arrays ja_tmp',res)
            
    

  end subroutine build_iaja_csr


  !>-------------------------------------------------------------
  !> Part of the static constructor
  !> (procedure private for type p1gal member assembler, used in init:
  !> allocation and construction)
  !>
  !> usage:
  !>     call build_assembler_csr(lun_err,nnode,ncell,nterm,ia,ja,triang,assembler)
  !>
  !> where:
  !> \param[in ] nnode   -> integer. Number of Nodes
  !> \param[in ] ncell   -> integer. Number of triangles
  !> \param[in ] nterm   -> integer. Number of non-zero element
  !> \param[in ] ia      -> integer(N+1) : Pointer of diagonal element
  !> \param[in ] ja      -> integer(nterm) : Pointer to column index of 
  !> \parma[in ] triang  -> integer(4,ncell) :Nodes in triangle + material 
  !> \parma[out] assembler   -> integer(3,3,ncell) : Pointer  
  !<-------------------------------------------------------------
  subroutine build_assembler_csr(&
       nnode, ncell, nnodeincell,&
       nterm, ia ,ja,  assembler,grid)
    use Globals
    implicit none
    integer, intent(in ) :: nnode, ncell, nnodeincell,nterm
    integer, intent(in ) :: ia(nnode+1), ja(nterm)
    integer, intent(out) :: assembler(nnodeincell,nnodeincell,ncell)
    class(abs_simplex_mesh),intent(in) :: grid
    ! local variables
    integer :: icell,i,j,ii,jj,kk,ind,inode(4),start,tobefound,nnodeicell
    
    ! construction of assembler
    assembler=0
    do icell=1,ncell
       ! copy nodes
       call grid%get_nodes_in_cell(icell,nnodeincell,inode(1:nnodeincell))
       !
       ! find the iterm of sparse matrix corresponding
       ! to term (ii,jj)=(triang(i,icell),triang(j,icell)
       !
       do i=1,nnodeincell
          ii=inode(i)
          do j=1,nnodeincell
             jj=inode(j)
             ind=ia(ii)
             do while ( ja(ind) .ne. jj )
                ind=ind+1
             end do
             assembler(j,i,icell)=ind
          end do
       end do
    end do
  end subroutine build_assembler_csr


  !>-------------------------------------------------------------------
  !> Procedure for building integral of P1 basis function
  !> (procedure public for type p1gal)
  !>
  !> usage:
  !>     call 'var'%int_test(grid, data, integral)
  !>
  !> where:
  !> \param[in ] data                -> real. (Dimension=this%ncell)
  !>                                     Constant data on the tetrahedrons
  !> \param[out] integral            -> real. (Dimension=this%nbasis)
  !>                                     integral(i)=\Int_{\Domain}data\Psi_{i}
  !<-------------------------------------------------------------------
  subroutine int_test(this, data, integral)
    use Globals
    implicit none
    class(p1gal),         intent(in   ) :: this
    real(kind=double),    intent(in   ) :: data(this%ncell)
    real(kind=double),    intent(inout) :: integral(this%nbasis)
    !local variable
    integer :: inode, icell, iloc, ncell, nnodeincell, nodes(4) ! this is big enough
    real(double) ::  basefun_on_bar
    
    ncell       = this%grid%ncell
    nnodeincell = this%grid%get_nnodes_in_cell(1) ! smae of all cell, so we pass 1
    
    basefun_on_bar = one / nnodeincell

    integral = zero
    do icell = 1, ncell
       ! get the list of nodes 
       call this%grid%get_nodes_in_cell(icell,nnodeincell,nodes(1:nnodeincell))
       do iloc = 1,nnodeincell
          inode = nodes(iloc)
          integral(inode) = integral(inode) + &
               data(icell)*this%grid%size_cell(icell)* basefun_on_bar
       end do
    end do
   
  end subroutine int_test

  !>-------------------------------------------------------------------
  !> Build rhs of elliptic equation given forcing and Neumann 
  !> terms
  !> (procedure public for type p1gal)
  !>
  !> usage:
  !>     call 'var'%build_rhs_forcing(forcing, rhs_forcing, neum)
  !>
  !> where:
  !> \param[in ] forcing       -> real. Forcing constant over tetrahedrons
  !> \param[in ] neum          -> real. Neumann boundary conditions
  !> \param[out] rhs_forcing   -> real. Right hand side of the system
  !<-------------------------------------------------------------------
  subroutine build_rhs_forcing(this, forcing, rhs_forcing)
    use Globals
    implicit none
    class(p1gal),          intent(in   ) :: this
    real(kind=double),     intent(in   ) :: forcing(this%grid%ncell)
    real(kind=double),     intent(inout) :: rhs_forcing(this%grid%nnode)
    !local 
    integer :: inode, icell, iedge, iloc

    rhs_forcing = zero 
    
    call this%int_test(forcing, rhs_forcing)
    
  end subroutine build_rhs_forcing

  !>-------------------------------------------------------------
  !> Procedure for evaluation of gradient of a $P1(\Tau(\Omega))$
  !> basis function in a cell
  !> (procedure public for type p1gal)
  !>
  !> usage:
  !>     call "var"%get_gradbase(this,iloc,icell,basis_grad)
  !>
  !> where:
  !> \param[in] iloc         -> integer. basis index 
  !> \param[in] icell        -> integer. Cell index 
  !> \param[in] basis_grad   -> real dimension(logical_dimension). 
  !>                            grad($\phi_h$) $\phi_h\in P1_h$ 
  !<-------------------------------------------------------------
  subroutine get_gradbase(this,iloc,icell,basis_gradient)
    use Globals
    implicit none
    class(p1gal),      intent(in ) :: this
    integer,           intent(in ) :: iloc
    integer,           intent(in ) :: icell
    real(kind=double), intent(out) :: &
         basis_gradient(this%grid%logical_dimension)

    basis_gradient(:) = &
         this%grad_basis(1:this%grid%logical_dimension,iloc,icell)

    
    
  end subroutine get_gradbase

  
  !>-------------------------------------------------------------
  !> Static constructor.
  !> (procedure public for type p1 gal
  !> Instantiate and initialize )
  !>
  !> usage:
  !>     call 'var'%init(this, lun_err, grid)
  !>
  !> where:
  !> \param[in] lun_err -> integer. Logic unit for error message
  !> \param[in] grid    -> type(mesh). Data of the triangulation
  !<-------------------------------------------------------------
  subroutine genrcm(this, lun_err, lun_out, grid, perm, inv_perm)
    use Globals
    use SparseMatrix
    implicit none
    !vars
    class(p1gal),intent(inout) :: this
    integer,     intent(in   ) :: lun_err
    integer,     intent(in   ) :: lun_out
    type(abs_simplex_mesh),  intent(inout) :: grid
    integer,     intent(inout) :: perm(grid%nnode)
    integer,     intent(inout) :: inv_perm(grid%nnode)

    ! local variables
    logical :: rc
    integer :: res
    integer :: nnode,n1,ncell,i,k,m,nterm
    type(spmat) :: adj_matrix,adj_temp
    type(p1gal) :: p1_loc
    
    !
    ! The adj. matrix of the p1-Galerkin used to
    ! build the rcm permutation is
    ! the connectivity of the triagulation
    ! without the diagonal terms

    !
    !
    ! build ia_csr, ja_csr and nterm_csr for csr format
    !
    n1=30
    call p1_loc%build_iaja_csr(lun_err,n1,grid)
    call adj_temp%init(lun_err,&
         grid%nnode,grid%nnode, p1_loc%nterm_csr,&
         storage_system='csr',&
         is_symmetric=.true.)
    !
    ! remove diagonal term
    !
    do i=1,grid%nnode
       adj_temp%ja(adj_temp%idiag(i)) = 0
    end do
    m=0
    do k=1,adj_temp%nterm
       if (adj_temp%ja(k).ne.0) then 
          m=m+1
          adj_temp%ja(m)=adj_temp%ja(k)
       end if
    end do
    nterm=m
    
    !
    ! correct ia
    !
    do i=2,grid%nnode+1
       adj_temp%ia(i) = adj_temp%ia(i)-i+1
    end do
    
    !
    ! build adjency matrix
    !
    call adj_matrix%init(lun_err,&
         grid%nnode,grid%nnode, nterm,&
         storage_system='csr',&
         is_symmetric=.true.)
    adj_matrix%ia=adj_temp%ia
    adj_matrix%ja(1:nterm)=adj_temp%ja(1:nterm)

    !
    ! create permutation
    !
    call adj_matrix%genrcm(lun_err,perm,inv_perm)


    !
    ! free memory
    !
    call adj_matrix%kill(lun_err)    
    call adj_temp%kill(lun_err)
    call p1_loc%kill(lun_err)
    
  end subroutine genrcm

  !>-------------------------------------------------------------
  !> Procedure to fix dirichlet boundary condition.
  !> Preprocess matrix, rhs and solution of the linear system
  !>         matrix sol = rhs
  !> so that $sol(noddir(i))=soldir(noddir(i)) \forall i\in 1,ndir$
  !> 
  !> (procedure public for type p1 gal)
  !>
  !> usage:
  !>     call 'var'%init(lun_err, &
  !>                     matrix, rhs, sol,&
  !>                     ndir, noddir, soldir)
  !>
  !> where:
  !> \param[in   ] lun_err-> integer. Logic unit for error message
  !> \param[inout] matrix -> type(spmat). Sparse matrix to be preprocessed
  !> \param[inout] rhs    -> real(dimension=matrix%row). System rhs
  !> \param[inout] sol    -> real(dimension=matrix%col). System solution
  !> \param[in   ] ndir   -> integer. Number of Dirichlet nodes
  !> \param[in   ] noddir -> integer(dimension=ndir). Indeces of 
  !>                            Dirichlet nodes
  !> \param[in   ] soldir -> real(dimension=ndir). Values on 
  !>                            Dirichlet nodes
  !<-------------------------------------------------------------
  subroutine dirichlet_bc(this,lun_err,&
       matrix, rhs, sol,&
       ndir, noddir, soldir)
    use Globals
    use SparseMatrix
    class(p1gal),      intent(in) :: this
    type(spmat),       intent(inout) :: matrix
    integer,           intent(in   ) :: lun_err
    real(kind=double), intent(inout) :: rhs(matrix%nrow)
    real(kind=double), intent(inout) :: sol(matrix%ncol)
    integer,           intent(in   ) :: ndir
    integer,           intent(in   ) :: noddir(ndir)
    real(kind=double), intent(in   ) :: soldir(ndir)
    ! local
    logical :: rc
    integer :: res
    integer :: idir,inode
    real(kind=double) :: solnode,diagvalue
    real(kind=double), allocatable :: scr(:)
    
    
    if ( ndir .gt. 0) then
       if  (matrix%is_symmetric) then
          do idir= 1,ndir
             !
             ! local copy
             !
             inode = noddir(idir)
             diagvalue = matrix%coeff(matrix%idiag(inode))
             solnode  = soldir(idir) 
             !
             ! First operate the correction of the rhs 
             ! 
             ! rhs = rhs - A * solnode * e(inode)
             !  
             ! where e(inode) is the zero vector with one at entry inode  
             !
             ! Then fix rhs(inode) = solnode

             ! 
             ! subroutine Mxaei operate in place of rhs
             !
             if ( solnode .ne. zero ) &
                  call matrix%aMxei(lun_err, inode, -solnode,rhs)
             rhs(inode) = solnode!* diagvalue  
             !
             ! set to zero entries of idir-column and row-idir   
             !
             call matrix%set_rowcol(inode,zero)

             !
             ! set one the diagonal
             !
             matrix%coeff(matrix%idiag(inode))=one !diagvalue

             !
             ! set solution to initail solution
             !
             sol(inode) = solnode
          end do
       else
          do idir= 1,ndir
             inode = noddir(idir)
             diagvalue = matrix%coeff(matrix%idiag(inode))
             solnode  = soldir(idir) 
             rhs(inode) = solnode
             !
             ! set to zero entries of idir-row   
             !
             call matrix%set_row(inode,zero)
             !
             ! set one the diagonal term
             !
             matrix%coeff(matrix%idiag(inode))=one 
          end do


       end if
    end if
 
  end subroutine dirichlet_bc
  
  subroutine gradbase2spmat(&
       this,lun_err,&
       gradx, grady, gradz)
    use SparseMatrix
    implicit none
    class(p1gal),      intent(in   ) :: this
    integer,           intent(in   ) :: lun_err
    type(spmat),       intent(inout) :: gradx
    type(spmat),       intent(inout) :: grady
    type(spmat), optional, intent(inout) :: gradz
    !local
    integer :: icell, i,iloc, j,nnodeincell,nodes(4)
    real(kind=double) :: gradloc(this%grid%logical_dimension)

    nnodeincell = this%grid%get_nnodes_in_cell(1)
    
    call gradx%init(lun_err,&
         this%grid%ncell, this%grid%nnode, this%grid%ncell*3,&
         storage_system='csr')
    
    call grady%init(lun_err,&
         this%grid%ncell, this%grid%nnode, this%grid%ncell*3,&
         storage_system='csr')
    
    
    gradx%ia(1) = 1
    do icell=1,this%grid%ncell
       gradx%ia(icell+1) = gradx%ia(icell)+3
       ! get the list of nodes 
       call this%grid%get_nodes_in_cell(icell,nnodeincell,nodes(1:nnodeincell))
       do iloc=1,3
          j=gradx%ia(icell)+iloc-1 
          gradx%ja(j)    = nodes(iloc)
          call this%get_gradbase(iloc,icell,gradloc)
          gradx%coeff(j) = gradloc(1)
       end do
    end do

    grady%ia(1) = 1
    do icell=1,this%grid%ncell
       grady%ia(icell+1) = grady%ia(icell)+3
       ! get the list of nodes 
       call this%grid%get_nodes_in_cell(icell,nnodeincell,nodes(1:nnodeincell))
       do iloc=1,3
          j=grady%ia(icell)+iloc -1 
          grady%ja(j)    = nodes(iloc)
          call this%get_gradbase(iloc,icell,gradloc)
          grady%coeff(j) = gradloc(2)
       end do
    end do

    if (this%grid%logical_dimension.eq.3) then       
       if (present(gradz) ) then
          call gradz%init(lun_err,&
               this%grid%ncell, this%grid%nnode, this%grid%ncell*3,&
               storage_system='csr')
          gradz%ia(1) = 1
          do icell=1,this%grid%ncell
             gradz%ia(icell+1) = gradz%ia(icell)+3
             ! get the list of nodes 
             call this%grid%get_nodes_in_cell(icell,nnodeincell,nodes(1:nnodeincell))
             do iloc=1,3
                j=gradz%ia(icell)+iloc -1 
                gradz%ja(j)    = nodes(iloc)
                call this%get_gradbase(iloc,icell,gradloc)
                gradz%coeff(j) = gradloc(3)
             end do
          end do
       end if
    end if
    
  end subroutine gradbase2spmat
  
  !>-------------------------------------------------------------
  !> Function to build local conductivity matrix
  !> $K=\{\k_ij\}$ from the conductivity vector cond
  !> which contains the lower simmetric elements by row
  !> Example (for logical_dimension=2):
  !>     (k11 k12 k22)_icell
  !>
  !> (procedure private for type p1gal)
  !>
  !> usage:
  !>     cond_loc = get_cond_loc(ncell,ldim,icell,cond)
  !>
  !> where:
  !>
  !<-------------------------------------------------------------
  function get_cond_loc(ncell,ldim,icell,cond) result(cond_loc)
    use Globals
    implicit none
    !vars
    integer, intent(in) :: ncell, ldim, icell
    real(kind=double), intent(in) :: cond(ldim*(ldim+1)/2*ncell)
    real(kind=double) :: cond_loc(ldim,ldim)
    ! local vars
    integer :: nsize,iloc,jloc

    nsize = ldim*(ldim+1)/2
    do iloc=1,ldim
       do jloc=iloc,ldim
          cond_loc(iloc,jloc) = cond(nsize*(icell-1)+iloc+(jloc-1)*jloc/2)
          cond_loc(jloc,iloc) = cond_loc(iloc,jloc)
       end do
    end do

  end function get_cond_loc

  !>-------------------------------------------------------------
  !> Part of the static constructor
  !> (procedure private for type p1gal,used in init)
  !> 
  !> Procedure to compute integer pointers ia, ja and assembler
  !> given the number of degrees of freedom for each node. 
  !> It defines the number of non-zero terms and the number of rows
  !>
  !> usage:
  !>     call 'var'%build_ia_ja_assembler_saintvenant_csr()
  !<-------------------------------------------------------------
  subroutine build_csr_multi_dofs(this)		
  
    implicit none
    ! Input and output variables
    class(p1gal), intent(inout), target :: this
    
    ! local variables
    integer :: i, j, k, l, m, n, ii, jj,nodes(4)
    integer :: localnz, ind, dofsxcell
    integer, pointer     :: nterms_old  => NULL()
    integer, pointer     :: nterms_new  => NULL()
    integer, pointer     :: nrows       => NULL()
    integer, pointer     :: ncell       => NULL()
    integer, pointer     :: nnodeincell => NULL()
    integer, pointer     :: dofsxnode   => NULL()
    integer, pointer     :: ia_old(:)   => NULL()
    integer, pointer     :: ja_old(:)   => NULL()
    integer, pointer     :: ia_new(:)   => NULL()
    integer, pointer     :: ja_new(:)   => NULL()
    integer, pointer     :: trija(:,:,:)=> NULL()
    integer, allocatable :: inode(:)    
    ! local
    logical :: rc
    integer :: res
    
    ! Number of nodes mesh
    nrows => this%grid%nnode
    ! Number of cell mesh
    ncell => this%grid%ncell
    ! Number of nodes in cell mesh
    nnodeincell => this%grid%nnodeincell
    ! Number of non-zero terms starting pattern
    nterms_old => this%nterm_csr
    ! Ambient dimension problem
    dofsxnode => this%grid%ambient_dimension

    ! Pointers to old integer array ia and ja
    ia_old => this%ia_csr
    ja_old => this%ja_csr

    ! Define the number of non-zero terms in the new pattern
    this%nterm_saint_venant_csr = nterms_old * (dofsxnode)**2
    ! Pointer to the new number of non-zero terms
    nterms_new => this%nterm_saint_venant_csr

    ! Allocate new integer array ia and ja
    allocate(this%ia_saint_venant_csr(dofsxnode*nrows+1),&
	     this%ja_saint_venant_csr(nterms_new),stat=res)
    if (res.ne.0) STOP "errore allocazione nuovi array ia e ja"

    ! Puntatori nuovi array ia e ja
    ia_new => this%ia_saint_venant_csr
    ja_new => this%ja_saint_venant_csr

    ! Costruzione dei nuovi vettori ia e ja
    ia_new(1) = ia_old(1)
    do i = 1,nrows
       localnz = ia_old(i+1) - ia_old(i)
       do j = 1,dofsxnode
          k = dofsxnode*(i-1)+j	       
          ia_new(k+1) = ia_new(k) + dofsxnode*localnz
	  do l = 1,dofsxnode
	     do m = 0,(localnz-1)
		n = ia_new(k) + dofsxnode*(m+1)-l
		ja_new(n) = dofsxnode*ja_old(ia_old(i)+m)+1-l
	     end do
	  end do
       end do 
    end do

    ! Number of dofs for each cell
    dofsxcell = dofsxnode*nnodeincell

    ! Allocate new assembler
    allocate(this%assembler_saint_venant_csr(dofsxcell,dofsxcell,ncell),stat=res)
    if (res.ne.0) STOP "errore allocazione array trija" 
    ! Pointer to new assembler
    trija => this%assembler_saint_venant_csr

    ! Allocate local array
    allocate(inode(dofsxcell),stat=res)
    if (res.ne.0) STOP "errore allocazione array locali"

    ! Build new assembler
    do k = 1,ncell

       call this%grid%get_nodes_in_cell(k,nnodeincell,nodes(1:nnodeincell))
       do i = 1,nnodeincell
          l = nodes(i)
          m = dofsxnode*(l-1)
          do j = 1,dofsxnode
             n = j + dofsxnode*(i-1)
             inode(n) = m+j
          end do
       end do
       do i = 1,dofsxcell
			 ii = inode(i)
			 do j = 1,dofsxcell
             jj = inode(j)
				 trija(i,j,k) = 0
				 ind = ia_new(ii)
				 do while (ja_new(ind).ne.jj)
					 ind = ind + 1
				 end do
				 trija(i,j,k) = ind
          end do
       end do
    end do

    ! Free space local array
    deallocate(inode,stat=res)
    if (res.ne.0) STOP "errore deallocazione inode"

  end subroutine build_csr_multi_dofs


  !>-------------------------------------------------------------
  !> Procedure for build the stiffness matrix of the Saint Venant 
  !> equation in 2D. The format of the produced stiffness matrix
  !> is csr.
  !>
  !> usage:
  !>     call 'var'%build_stiff_saint_venant(lun_err,&
  !>			cond,mu,lambda,stiff)
  !>
  !> where:
  !> \param[in   ] lun_err         -> integer. I/O unit err. msg.
  !> \param[in   ] mu              -> real(double). First Lamè constant
  !> \param[in   ] lambda          -> real(double). Second Lamè constant
  !> \param[in   ] cond            -> real(double).
  !>                                  assumed dimension:
  !>                                  - ncell   = scalar value
  !> \param[inout] stiff           -> spmat. Stiffness matrix
  !<-------------------------------------------------------------
  subroutine build_stiff_saint_venant(p1,lun_err,cond,mu,lambda,stiff)

  Use Globals
  Use SparseMatrix

  implicit none
  ! Input/Output variables
  class(p1gal),      intent(in   ) :: p1
  integer, 	     intent(in   ) :: lun_err
  type(spmat),       intent(inout) :: stiff
  real(kind=double), intent(in   ) :: cond(:)
  real(kind=double), intent(in   ) :: mu
  real(kind=double), intent(in   ) :: lambda

  ! Local variables
  logical :: rc
  integer :: res
  integer :: dofsxnode, dim_voigt
  integer :: nbasis, ndof, nterm, ncell, dofsxcell, nnodeincell  
  integer :: i, j, icell, ind, k, iloc, jloc, p, local_ind(3,3)
  logical :: check_matrix
  real(kind=double), allocatable, dimension(:,:) :: C, R, Hloc

  nbasis      = p1%nbasis
  nnodeincell = p1%grid%nnodeincell
  dofsxnode   = p1%grid%ambient_dimension
  dofsxcell   = dofsxnode*nnodeincell
  ndof        = nbasis*dofsxnode
  nterm       = p1%nterm_saint_venant_csr
  ncell       = p1%grid%ncell

  dim_voigt = 0
  do i = 1,dofsxnode
	  dim_voigt = dim_voigt + i
  end do

  ! If the matrix is not initilized then initilize
  ! otherwise check if it has been initilized correctly
  if (.not.stiff%is_initialized) then
     call stiff%init(lun_err,ndof,ndof,nterm,&
	     storage_system='csr',is_symmetric=.true.)
  else
     check_matrix = stiff%check(ndof,ndof,nterm,&
             storage_system='csr',is_symmetric=.true.)
     if (.not.check_matrix) then
	rc = IOerr(lun_err, err_val, 'build_stiff_saint_venant',&
		'matrix has not the proper dimension')
     end if
  end if

  ! Assign ia and ja
  stiff%ia = p1%ia_saint_venant_csr
  stiff%ja = p1%ja_saint_venant_csr
  
  ! Build the pointers to diagonal coefficients
  call stiff%build_ind_diag(lun_err)

  ! Initilize the array coeff
  stiff%coeff = zero

  ! Allocate matrices
  allocate(C(dim_voigt,dim_voigt),R(dim_voigt,dofsxcell),&
	  Hloc(dofsxcell,dofsxcell),stat=res)
  if (res.ne.0) rc = IOerr(lun_err, err_alloc, 'build_stiff_saint_venant',&
		 'allocation matrices R, C and HLOC')

  ! Constitutive tensor
  C = 0
  do i = 1,dofsxnode
	  do j = 1,dofsxnode
		  C(j,i) = lambda
	  end do
	  C(i,i) = C(i,i) + 2*mu
  end do
  do i = (dofsxnode+1),dim_voigt
	  C(i,i) = mu
  end do

  R = 0

  local_ind(1,1:3) = (/2, 1, 3/)
  local_ind(2,1:3) = (/3, 2, 1/)
  local_ind(3,1:3) = (/1, 3, 2/)

  ! Assembly all coefficients
  do icell = 1,ncell

	  ! Build local stiffness matrix
	  do j = 1,nnodeincell
		  do i = 1,dofsxnode
			  jloc = i+dofsxnode*(j-1)
			  R(i,jloc) = p1%grad_basis(i,j,icell)
			  do k = 1,(dim_voigt-dofsxnode)
				  iloc = k+dofsxnode
				  p = local_ind(k,i)
				  if (p.ne.i) R(iloc,jloc) = p1%grad_basis(p,j,icell)
			  end do
		  end do
	  end do

     ! Compute the local stiffness matrix 
     ! dimension: dofsxcell x dofsxcell
     Hloc = MATMUL(TRANSPOSE(R),MATMUL(C,R))

     ! Loop over the elements of the local stiff matrix
     do i = 1,dofsxcell
			do j = 1,dofsxcell
				! From local to global index
				ind = p1%assembler_saint_venant_csr(i,j,icell)
				! Coefficient assembly
				stiff%coeff(ind) = stiff%coeff(ind) + cond(icell)*&
				p1%grid%size_cell(icell)*Hloc(i,j)
         end do
      end do

   end do

  ! Allocate matrices
  deallocate(C,R,Hloc,stat=res)
  if (res.ne.0) rc = IOerr(lun_err, err_dealloc, 'build_stiff_saint_venant',&
		 'deallocation matrices R, C and HLOC')

end subroutine build_stiff_saint_venant


subroutine neumann_elasticity_rhs(this,rhs_in,rhs_out)

  implicit none

  ! Input and Output variables
  class(p1gal), target, intent(in   ) :: this
  real(kind=double),   intent(in   ) :: rhs_in(:)
  real(kind=double),   intent(inout) :: rhs_out(:)

  ! Local variables
  real(kind=double)					:: sum_area
  real(kind=double)					:: dotxy
  real(kind=double)					:: sumfx, sumfy
  real(kind=double)					:: ratio_fx_area, ratio_fy_area
  real(kind=double), allocatable :: rhsx(:), rhsy(:)
  real(kind=double), allocatable :: rotx(:), roty(:)
  real(kind=double), pointer     :: area(:)
  integer :: nnode, ncell, inode, nnodeincell
  integer :: icell, iloc, res, i,nodes(4)
  real(kind=double) :: coord(3)

  ! Pointers
  nnode = this%grid%nnode
  ncell = this%grid%ncell
  nnodeincell = this%grid%nnodeincell

  ! Compute \int_{\Omega} \partial_x \varphi_{i} dx
  ! Compute \int_{\Omega} \partial_y \varphi_{i} dx
  allocate(rotx(nnode),roty(nnode),stat=res)
  if (res.ne.0) STOP "errore allocazione rotx e roty. &
       Subroutine neumann_elasticity_res in type p1gal"

  rotx = zero
  roty = zero

  do icell = 1,ncell
     ! get node list 
     call this%grid%get_nodes_in_cell(icell,nnodeincell,nodes(1:nnodeincell))
     do iloc = 1,nnodeincell
        inode = nodes(iloc)
        rotx(inode) = rotx(inode) + &
             this%grid%size_cell(icell)*&
             this%grad_basis(1,iloc,icell)
        roty(inode) = roty(inode) - &
             this%grid%size_cell(icell)*&
             this%grad_basis(2,iloc,icell)
     end do
  end do

  ! Pointer to nodal area
  area => this%basis_integral

  ! Area \Omega
  sum_area = zero

  do i = 1,nnode
     sum_area = sum_area + area(i)
  end do

  ! Allocazione rhsx e rhsy
  allocate(rhsx(nnode),rhsy(nnode),stat=res)
  if (res.ne.0) STOP "errore allocazione rhsx e rhsy. &
       Subroutine neumann_elasticity_res in type p1gal"

  do i = 1,nnode
     rhsx(i) = rhs_in(i)
     rhsy(i) = rhs_in(i+nnode)
  end do

  sumfx = zero
  sumfy = zero

  do i = 1,nnode
     sumfx = sumfx + rhsx(i)
     sumfy = sumfy + rhsy(i)
  end do

  ratio_fx_area = sumfx/sum_area
  ratio_fy_area = sumfy/sum_area

  dotxy = zero

  
  do i = 1,nnode
     call this%grid%get_coord_of_node(i, coord)
     rhsx(i) = rhsx(i) - ratio_fx_area*area(i)
     rhsy(i) = rhsy(i) - ratio_fy_area*area(i)
     dotxy = dotxy + coord(2)*rhsx(i) - coord(1)*rhsy(i)
  end do

  dotxy = 0.5*(dotxy/sum_area)

  do i = 1,nnode
     rhsx(i) = rhsx(i) + dotxy*roty(i)
     rhsy(i) = rhsy(i) + dotxy*rotx(i)
  end do

  do i = 1,nnode
     rhs_out(i      ) = rhsx(i)
     rhs_out(i+nnode) = rhsy(i)
  end do

  !	  write(*,*) 'sum rhsx: ', sum(rhsx)
  !	  write(*,*) 'sum rhsy: ', sum(rhsy)
  !	  write(*,*) 'rhs coor: ', dot_product(rhsx,ycoord) - dot_product(rhsy,xcoord)

  deallocate(rotx,roty,stat=res)
  if (res.ne.0) STOP "errore deallocazione rotx, roty. &
       Subroutine neumann_elasticity_res in type p1gal"

  deallocate(rhsx,rhsy,stat=res)
  if (res.ne.0) STOP "errore deallocazione rhsx, rhsy. &
       Subroutine neumann_elasticity_res in type p1gal"

end subroutine neumann_elasticity_rhs

 subroutine neumann_elasticity_pot(this,pot_in,pot_out)

   implicit none

   ! Input and Output variables
   class(p1gal), target, intent(in   ) :: this
   real(kind=double),   intent(in   ) :: pot_in(:)
   real(kind=double),   intent(inout) :: pot_out(:)

   ! Local variables
   real(kind=double)					:: sum_area
   real(kind=double)					:: dotxy
   real(kind=double)					:: lx, ly, rx, ry
   real(kind=double), allocatable :: potx(:), poty(:)
   real(kind=double), allocatable :: rotx(:), roty(:)
   real(kind=double), pointer     :: xcoord(:), ycoord(:), area(:)
   integer :: nnode, ncell, inode, nnodeincell
   integer :: icell, iloc, res, i,nodes(4)
   real(kind=double) :: coord(4)


   ! Pointers
   nnode = this%grid%nnode
   ncell = this%grid%ncell
   nnodeincell = this%grid%nnodeincell

   ! Compute \int_{\Omega} \partial_x \varphi_{i} dx
   ! Compute \int_{\Omega} \partial_y \varphi_{i} dx
   allocate(rotx(nnode),roty(nnode),stat=res)
   if (res.ne.0) STOP "errore allocazione rotx e roty. &
        Subroutine neumann_elasticity_pot in type p1gal"

   rotx = zero
   roty = zero

   do icell = 1,ncell
      call this%grid%get_nodes_in_cell(icell,nnodeincell,nodes(1:nnodeincell))
      do iloc = 1,nnodeincell
         inode = nodes(4)
         rotx(inode) = rotx(inode) + &
              this%grid%size_cell(icell)*&
              this%grad_basis(1,iloc,icell)
         roty(inode) = roty(inode) - &
              this%grid%size_cell(icell)*&
              this%grad_basis(2,iloc,icell)
      end do
   end do

   ! Pointer to nodal area
   area => this%basis_integral

   ! Pointer to nodal coordinates
   xcoord => this%grid%coord(1,:)
   ycoord => this%grid%coord(2,:)

   ! Area \Omega
   sum_area = zero

   do i = 1,nnode
      sum_area = sum_area + area(i)
   end do

   ! Allocazione potx e poty
   allocate(potx(nnode),poty(nnode),stat=res)
   if (res.ne.0) STOP "errore allocazione potx e poty. &
        Subroutine neumann_elasticity_pot in type p1gal"

   do i = 1,nnode
      potx(i) = pot_in(i)
      poty(i) = pot_in(i+nnode)
   end do

   lx = zero
   ly = zero
   rx = zero
   ry = zero
   dotxy = zero

   do i = 1,nnode
      call this%grid%get_coord_of_node(i, coord)
      dotxy = dotxy + 0.5*roty(i)*potx(i) + 0.5*rotx(i)*poty(i)
      lx = lx + potx(i)*area(i)
      ly = ly + poty(i)*area(i)
      rx = rx + coord(2)*area(i)
      ry = ry + coord(1)*area(i)
   end do

   lx = lx/sum_area
   ly = ly/sum_area
   rx = rx/sum_area
   ry = ry/sum_area
   dotxy = dotxy/sum_area

   ! Update solution
   do i = 1,nnode
      call this%grid%get_coord_of_node(i, coord)
      potx(i) = potx(i) - lx + dotxy*(+coord(2) - rx)
      poty(i) = poty(i) - ly + dotxy*(-coord(1) + ry)
   end do

   do i = 1,nnode
      pot_out(i      ) = potx(i)
      pot_out(i+nnode) = poty(i)
   end do

   !	  write(*,*) 'sum area pot: ', dot_product(potx,area)
   !	  write(*,*) 'sum area pot: ', dot_product(poty,area)
   !	  write(*,*) 'sum area rot: ', dot_product(poty,rotx) + dot_product(potx,roty)

   deallocate(rotx,roty,stat=res)
   if (res.ne.0) STOP "errore deallocazione rotx, roty. &
        Subroutine neumann_elasticity_pot in type p1gal"

   deallocate(potx,poty,stat=res)
   if (res.ne.0) STOP "errore deallocazione potx, poty. &
        Subroutine neumann_elasticity_pot in type p1gal"

 end subroutine neumann_elasticity_pot


end module P1Galerkin

